<!DOCTYPE html>
<html lang="bn">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‡¶¶‡¶æ‡¶Ø‡¶º‡¶ø‡¶§‡ßç‡¶¨ ‡¶¨‡¶®‡ßç‡¶ü‡¶® ‡¶ú‡ßá‡¶®‡¶æ‡¶∞‡ßá‡¶ü‡¶∞</title>
    <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
    <script src="../authentication.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Nikosh', 'SolaimanLipi', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        }
        
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
            font-size: 32px;
            border-bottom: 3px solid #667eea;
            padding-bottom: 15px;
        }
        
        .controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        .btn {
            padding: 12px 30px;
            font-size: 16px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        
        .btn-success {
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
            color: white;
        }
        
        .btn-success:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(56, 239, 125, 0.4);
        }
        
        .btn-print {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
        }
        
        .btn-print:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(245, 87, 108, 0.4);
        }
        
        .btn-regenerate {
            background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
            color: white;
        }
        
        .btn-regenerate:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(250, 112, 154, 0.4);
        }
        
        .btn-load {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
        }
        
        .btn-load:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(79, 172, 254, 0.4);
        }
        
        .status {
            padding: 12px 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: none;
        }
        
        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        
        .status.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        
        .loading {
            display: none;
            text-align: center;
            padding: 20px;
        }
        
        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .centres-container {
            margin-top: 30px;
        }
        
        .centre-card {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            border: 2px solid #e9ecef;
            page-break-after: always;
        }
        
        .centre-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            text-align: center;
        }
        
        .centre-header .centre-meta {
            font-size: 1rem;
            font-weight: 600;
            opacity: 0.95;
            margin-bottom: 6px;
        }
        
        .centre-header h2 {
            margin-bottom: 5px;
        }
        
        .assignment-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
            background: white;
            border-radius: 8px;
            overflow: hidden;
        }
        
        .assignment-table th {
            background: #667eea;
            color: white;
            padding: 12px;
            text-align: center;
            font-weight: bold;
        }
        
        .assignment-table td {
            padding: 10px;
            border: 1px solid #dee2e6;
        }
        
        .assignment-table tbody tr:hover {
            background: #f8f9fa;
        }
        
        .officer-name {
            font-weight: bold;
            color: #333;
        }
        
        .officer-designation {
            color: #666;
            font-size: 0.9em;
        }
        
        @media print {
            body {
                background: white;
                padding: 0;
            }
            
            .container {
                box-shadow: none;
                padding: 0;
            }
            
            .controls, .status, .loading {
                display: none !important;
            }
            
            .centre-card {
                page-break-after: always;
                margin-bottom: 0;
            }
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }
        
        .stat-number {
            font-size: 28px;
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .stat-label {
            font-size: 14px;
            opacity: 0.9;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üó≥Ô∏è ‡¶¶‡¶æ‡¶Ø‡¶º‡¶ø‡¶§‡ßç‡¶¨ ‡¶¨‡¶®‡ßç‡¶ü‡¶® ‡¶è‡¶≤‡¶ó‡¶∞‡¶ø‡¶¶‡¶Æ</h1>
        
        <div class="status" id="status"></div>
        
      
        
        <div class="controls">
            <button class="btn btn-load" id="loadBtn" onclick="loadFromDatabase()">
                üìÇ ‡¶°‡¶æ‡¶ü‡¶æ‡¶¨‡ßá‡¶∏ ‡¶•‡ßá‡¶ï‡ßá ‡¶ì‡¶™‡ßá‡¶® ‡¶ï‡¶∞‡ßÅ‡¶®
            </button>
            <button class="btn btn-regenerate" id="regenerateBtn" onclick="regenerateAssignments()">
                üîÑ ‡¶®‡¶§‡ßÅ‡¶® ‡¶ï‡¶∞‡ßá ‡¶¨‡¶®‡ßç‡¶ü‡¶® ‡¶ï‡¶∞‡ßÅ‡¶®
            </button>
            <button class="btn btn-success" id="saveBtn" onclick="saveAssignments()" style="display:none;">
                üíæ ‡¶∏‡¶Ç‡¶∞‡¶ï‡ßç‡¶∑‡¶£ ‡¶ï‡¶∞‡ßÅ‡¶®
            </button>
            <button class="btn btn-print" id="printBtn" onclick="window.print()">
                üñ®Ô∏è ‡¶™‡ßç‡¶∞‡¶ø‡¶®‡ßç‡¶ü ‡¶ï‡¶∞‡ßÅ‡¶®
            </button>
        </div>
        
        <div class="loading" id="loading">
            <div class="spinner"></div>
            <p>‡¶™‡ßç‡¶∞‡¶∏‡ßá‡¶∏‡¶ø‡¶Ç ‡¶ö‡¶≤‡¶õ‡ßá... ‡¶Ö‡¶®‡ßÅ‡¶ó‡ßç‡¶∞‡¶π ‡¶ï‡¶∞‡ßá ‡¶Ö‡¶™‡ßá‡¶ï‡ßç‡¶∑‡¶æ ‡¶ï‡¶∞‡ßÅ‡¶®...</p>
        </div>
        
        <div class="stats-grid" id="statsGrid" style="display:none;"></div>
        
        <div class="centres-container" id="centresContainer"></div>
    </div>

    <script>
        // Check authentication on page load
        window.addEventListener('DOMContentLoaded', () => {
            checkAuth();
            loadFromDatabase(); // Auto-load saved data on page load
        });
        
        let generatedData = [];
        
        // Helper function to get officer name (handles different column names)
        function getOfficerName(officer, type) {
            if (!officer) return 'N/A';
            
            if (type === 'presiding') {
                return officer.presiding_name || officer.name || 'N/A';
            } else if (type === 'ass_presiding') {
                return officer.ass_presiding_name || officer.name || 'N/A';
            } else if (type === 'polling') {
                return officer.polling_name || officer.name || 'N/A';
            }
            return officer.name || 'N/A';
        }

        function normalizeId(value) {
            return String(value ?? '').trim();
        }

        function isDisabled(person) {
            const disability = String(person?.disability ?? '').trim().toLowerCase();
            return disability === 'Yes';
        }

        function isAssigned(person) {
            const assignCode = String(person?.assign_code ?? '').trim();
            return assignCode !== '';
        }
        
        // Show status message
        function showStatus(message, type = 'info') {
            const statusDiv = document.getElementById('status');
            statusDiv.textContent = message;
            statusDiv.className = `status ${type}`;
            statusDiv.style.display = 'block';
            
            if (type === 'success') {
                setTimeout(() => {
                    statusDiv.style.display = 'none';
                }, 5000);
            }
        }
        
        // Show/hide loading
        function setLoading(isLoading) {
            document.getElementById('loading').style.display = isLoading ? 'block' : 'none';
            
            // Disable/enable buttons during loading
            const loadBtn = document.getElementById('loadBtn');
            const regenerateBtn = document.getElementById('regenerateBtn');
            const saveBtn = document.getElementById('saveBtn');
            
            if (loadBtn) loadBtn.disabled = isLoading;
            if (regenerateBtn) regenerateBtn.disabled = isLoading;
            if (saveBtn) saveBtn.disabled = isLoading;
        }
        
        // Shuffle array (Fisher-Yates algorithm)
        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }
        
        // Distribute by gender evenly
        function distributeByGender(people, count) {
            const male = people.filter(p => p.gender === 'Male' || p.gender === 'male');
            const female = people.filter(p => p.gender === 'Female' || p.gender === 'female');
            const unknown = people.filter(p => !p.gender || p.gender === 'Unknown' || p.gender === 'unknown');
            
            const maleShuffled = shuffleArray(male);
            const femaleShuffled = shuffleArray(female);
            const unknownShuffled = shuffleArray(unknown);
            
            const result = [];
            let maleIndex = 0, femaleIndex = 0, unknownIndex = 0;
            
            for (let i = 0; i < count; i++) {
                const cycle = i % 3;
                
                if (cycle === 0 && maleIndex < maleShuffled.length) {
                    result.push(maleShuffled[maleIndex++]);
                } else if (cycle === 1 && femaleIndex < femaleShuffled.length) {
                    result.push(femaleShuffled[femaleIndex++]);
                } else if (cycle === 2 && unknownIndex < unknownShuffled.length) {
                    result.push(unknownShuffled[unknownIndex++]);
                } else if (maleIndex < maleShuffled.length) {
                    result.push(maleShuffled[maleIndex++]);
                } else if (femaleIndex < femaleShuffled.length) {
                    result.push(femaleShuffled[femaleIndex++]);
                } else if (unknownIndex < unknownShuffled.length) {
                    result.push(unknownShuffled[unknownIndex++]);
                }
            }
            
            return result;
        }
        
        // Shuffle array with gender balance interleaving (for pre-shuffling entire list)
        function shuffleWithGenderBalance(people) {
            const male = shuffleArray(people.filter(p => p.gender === 'Male' || p.gender === 'male'));
            const female = shuffleArray(people.filter(p => p.gender === 'Female' || p.gender === 'female'));
            const unknown = shuffleArray(people.filter(p => !p.gender || p.gender === 'Unknown' || p.gender === 'unknown'));
            
            const result = [];
            let maleIndex = 0, femaleIndex = 0, unknownIndex = 0;
            const total = male.length + female.length + unknown.length;
            
            for (let i = 0; i < total; i++) {
                const cycle = i % 3;
                
                if (cycle === 0 && maleIndex < male.length) {
                    result.push(male[maleIndex++]);
                } else if (cycle === 1 && femaleIndex < female.length) {
                    result.push(female[femaleIndex++]);
                } else if (cycle === 2 && unknownIndex < unknown.length) {
                    result.push(unknown[unknownIndex++]);
                } else if (maleIndex < male.length) {
                    result.push(male[maleIndex++]);
                } else if (femaleIndex < female.length) {
                    result.push(female[femaleIndex++]);
                } else if (unknownIndex < unknown.length) {
                    result.push(unknown[unknownIndex++]);
                }
            }
            
            return result;
        }
        
        // Stratified sampling: ‡¶™‡ßç‡¶∞‡¶§‡¶ø ‡ßß‡ß¶‡ß¶ ‡¶ú‡¶®‡ßá‡¶∞ ‡¶ó‡ßç‡¶∞‡ßÅ‡¶™ ‡¶•‡ßá‡¶ï‡ßá ‡¶∏‡¶Æ‡¶æ‡¶® ‡¶∏‡¶Ç‡¶ñ‡ßç‡¶Ø‡¶ï ‡¶®‡¶ø‡¶∞‡ßç‡¶¨‡¶æ‡¶ö‡¶® ‡¶ï‡¶∞‡ßá
        // ‡¶è‡¶§‡ßá ‡¶∏‡¶¨ ‡¶Ö‡¶´‡¶ø‡¶∏‡¶æ‡¶∞‡¶¶‡ßá‡¶∞ ‡¶∏‡¶Æ‡¶æ‡¶® ‡¶∏‡ßÅ‡¶Ø‡ßã‡¶ó ‡¶•‡¶æ‡¶ï‡ßá (‡¶∂‡ßÅ‡¶∞‡ßÅ, ‡¶Æ‡¶æ‡¶ù‡¶ñ‡¶æ‡¶®, ‡¶∂‡ßá‡¶∑ - ‡¶∏‡¶¨‡¶æ‡¶∞ ‡¶•‡ßá‡¶ï‡ßá ‡¶∏‡¶Æ‡¶æ‡¶®)
        function stratifiedShuffle(people, chunkSize = 100) {
            if (people.length === 0) return [];
            
            // ‡¶™‡ßç‡¶∞‡¶•‡¶Æ‡ßá ‡¶™‡ßÅ‡¶∞‡ßã ‡¶≤‡¶ø‡¶∏‡ßç‡¶ü‡¶ï‡ßá ‡ßß‡ß¶‡ß¶ ‡¶ú‡¶®‡ßá‡¶∞ ‡¶ó‡ßç‡¶∞‡ßÅ‡¶™‡ßá ‡¶≠‡¶æ‡¶ó ‡¶ï‡¶∞‡¶ø
            const chunks = [];
            for (let i = 0; i < people.length; i += chunkSize) {
                const chunk = people.slice(i, i + chunkSize);
                // ‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ü‡¶ø ‡¶ö‡¶æ‡¶ô‡ßç‡¶ï ‡¶∂‡¶æ‡¶´‡ßá‡¶≤ ‡¶ï‡¶∞‡¶ø
                chunks.push(shuffleArray(chunk));
            }
            
            console.log(`   üìä Stratified shuffle: ${chunks.length} chunks of ~${chunkSize} each`);
            
            // ‡¶è‡¶ñ‡¶® ‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ü‡¶ø ‡¶ó‡ßç‡¶∞‡ßÅ‡¶™ ‡¶•‡ßá‡¶ï‡ßá ‡¶™‡¶æ‡¶≤‡¶æ‡¶ï‡ßç‡¶∞‡¶Æ‡ßá ‡¶è‡¶ï‡¶ú‡¶® ‡¶ï‡¶∞‡ßá ‡¶®‡¶ø‡¶á
            // ‡¶è‡¶§‡ßá ‡¶∏‡¶¨ ‡¶ó‡ßç‡¶∞‡ßÅ‡¶™ ‡¶•‡ßá‡¶ï‡ßá ‡¶∏‡¶Æ‡¶æ‡¶® ‡¶∏‡¶Ç‡¶ñ‡ßç‡¶Ø‡¶ï ‡¶®‡ßá‡¶ì‡¶Ø‡¶º‡¶æ ‡¶π‡¶¨‡ßá
            const result = [];
            const chunkIndices = chunks.map(() => 0); // ‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ü‡¶ø ‡¶ö‡¶æ‡¶ô‡ßç‡¶ï‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶á‡¶®‡¶°‡ßá‡¶ï‡ßç‡¶∏ ‡¶ü‡ßç‡¶∞‡ßç‡¶Ø‡¶æ‡¶ï
            
            let totalPicked = 0;
            const totalPeople = people.length;
            
            while (totalPicked < totalPeople) {
                let pickedThisRound = false;
                
                for (let c = 0; c < chunks.length; c++) {
                    if (chunkIndices[c] < chunks[c].length) {
                        result.push(chunks[c][chunkIndices[c]]);
                        chunkIndices[c]++;
                        totalPicked++;
                        pickedThisRound = true;
                    }
                }
                
                if (!pickedThisRound) break;
            }
            
            return result;
        }
        
        // Stratified + Gender balanced shuffle
        // ‡¶™‡ßç‡¶∞‡¶•‡¶Æ‡ßá ‡¶™‡ßÅ‡¶∞‡ßã ‡¶≤‡¶ø‡¶∏‡ßç‡¶ü‡ßá stratified (‡¶™‡ßç‡¶∞‡¶§‡¶ø ‡ßß‡ß¶‡ß¶ ‡¶ú‡¶® ‡¶•‡ßá‡¶ï‡ßá ‡¶∏‡¶Æ‡¶æ‡¶®), ‡¶§‡¶æ‡¶∞‡¶™‡¶∞ gender balance
        function stratifiedGenderBalancedShuffle(people, chunkSize = 100) {
            if (people.length === 0) return [];
            
            // ‡¶ß‡¶æ‡¶™ ‡ßß: ‡¶™‡ßç‡¶∞‡¶•‡¶Æ‡ßá ‡¶™‡ßÅ‡¶∞‡ßã ‡¶≤‡¶ø‡¶∏‡ßç‡¶ü‡ßá stratified shuffle ‡¶ï‡¶∞‡¶ø
            // ‡¶è‡¶§‡ßá ‡¶™‡ßç‡¶∞‡¶§‡¶ø ‡ßß‡ß¶‡ß¶ ‡¶ú‡¶®‡ßá‡¶∞ ‡¶ó‡ßç‡¶∞‡ßÅ‡¶™ ‡¶•‡ßá‡¶ï‡ßá ‡¶∏‡¶Æ‡¶æ‡¶® ‡¶∏‡¶Ç‡¶ñ‡ßç‡¶Ø‡¶ï ‡¶®‡¶ø‡¶∞‡ßç‡¶¨‡¶æ‡¶ö‡¶® ‡¶π‡¶¨‡ßá
            const stratified = stratifiedShuffle(people, chunkSize);
            
            console.log(`   üìä After stratified shuffle: ${stratified.length} people`);
            
            // ‡¶ß‡¶æ‡¶™ ‡ß®: ‡¶è‡¶ñ‡¶® stratified ‡¶≤‡¶ø‡¶∏‡ßç‡¶ü ‡¶•‡ßá‡¶ï‡ßá gender ‡¶Ü‡¶≤‡¶æ‡¶¶‡¶æ ‡¶ï‡¶∞‡¶ø
            const male = stratified.filter(p => p.gender === 'Male' || p.gender === 'male');
            const female = stratified.filter(p => p.gender === 'Female' || p.gender === 'female');
            const unknown = stratified.filter(p => !p.gender || p.gender === 'Unknown' || p.gender === 'unknown');
            
            console.log(`   üë• Gender split (after stratified): Male=${male.length}, Female=${female.length}, Unknown=${unknown.length}`);
            
            // ‡¶ß‡¶æ‡¶™ ‡ß©: Gender interleave ‡¶ï‡¶∞‡¶ø (M, F, U, M, F, U...)
            const result = [];
            let maleIndex = 0, femaleIndex = 0, unknownIndex = 0;
            const total = male.length + female.length + unknown.length;
            
            for (let i = 0; i < total; i++) {
                const cycle = i % 3;
                
                if (cycle === 0 && maleIndex < male.length) {
                    result.push(male[maleIndex++]);
                } else if (cycle === 1 && femaleIndex < female.length) {
                    result.push(female[femaleIndex++]);
                } else if (cycle === 2 && unknownIndex < unknown.length) {
                    result.push(unknown[unknownIndex++]);
                } else if (maleIndex < male.length) {
                    result.push(male[maleIndex++]);
                } else if (femaleIndex < female.length) {
                    result.push(female[femaleIndex++]);
                } else if (unknownIndex < unknown.length) {
                    result.push(unknown[unknownIndex++]);
                }
            }
            
            return result;
        }
        
        // Fetch all data with pagination (bypass Supabase 1000 row limit)
        async function fetchAllData(tableName, idColumnName, filterCallback = null) {
            let allData = [];
            let lastId = 0;
            const batchSize = 1000;
            let hasMore = true;
            let batchCount = 0;
            const maxBatches = 100;
            
            console.log(`üìä Fetching all data from ${tableName}...`);
            
            while(hasMore && batchCount < maxBatches) {
                batchCount++;
                console.log(`   Batch ${batchCount}, lastId: ${lastId}`);
                
                const { data, error } = await window.supabaseClient
                    .from(tableName)
                    .select('*')
                    .gt(idColumnName, lastId)
                    .order(idColumnName, { ascending: true })
                    .limit(batchSize);
                
                if (error) {
                    console.error(`‚ùå Error fetching ${tableName}:`, error);
                    throw error;
                }
                
                if (!data || data.length === 0) {
                    hasMore = false;
                    break;
                }
                
                // Apply filter if provided
                const filteredData = filterCallback ? data.filter(filterCallback) : data;
                allData.push(...filteredData);
                
                lastId = data[data.length - 1][idColumnName];
                console.log(`   Loaded ${data.length} rows, filtered to ${filteredData.length}, total: ${allData.length}`);
            }
            
            console.log(`‚úÖ ${tableName}: Total ${allData.length} records loaded in ${batchCount} batches`);
            return allData;
        }
        
        // Generate assignments
        async function generateAssignments() {
            setLoading(true);
            generatedData = [];
            document.getElementById('centresContainer').innerHTML = '';
            document.getElementById('statsGrid').style.display = 'none';
            
            try {
                console.log('üöÄ Starting assignment generation...');
                
                // Check Supabase connection
                if (!window.supabaseClient) {
                    throw new Error('Supabase client not initialized. Please check authentication.js');
                }
                
                // Fetch request_table data first
                console.log('üìä Fetching request_table for priority assignments...');
                const requestData = await fetchAllData('request_table', 'request_id');
                console.log(`‚úÖ Found ${requestData.length} priority assignments from request_table`);
                
                // Log request_table data for debugging
                if (requestData.length > 0) {
                    console.log('üìã Sample request_table entries:', requestData.slice(0, 3));
                }
                
                // Group request data by vote_centre_iid (normalize to string for matching)
                const requestByCentreIid = new Map();
                requestData.forEach(req => {
                    const centreIid = String(req.vote_centre_iid || '').trim();
                    if (centreIid && centreIid !== '' && centreIid !== 'null' && centreIid !== 'undefined') {
                        if (!requestByCentreIid.has(centreIid)) {
                            requestByCentreIid.set(centreIid, []);
                        }
                        requestByCentreIid.get(centreIid).push(req);
                        console.log(`üìå Request: Officer ${req.officer_name} (${req.officer_table_name}) ‚Üí Centre IID ${centreIid} (Code: ${req.vote_centre_code})`);
                    }
                });
                
                console.log(`üìä Grouped requests for ${requestByCentreIid.size} centre IIDs`);
                console.log(`üìã Centre IIDs in request_table:`, Array.from(requestByCentreIid.keys()));
                
                // Collect all requested officer IDs for verification
                const requestedOfficerIds = {
                    presiding: new Set(),
                    ass_presiding: new Set(),
                    polling: new Set()
                };
                requestData.forEach(req => {
                    const id = String(req.officer_table_iid || '').trim();
                    if (id && req.officer_table_name) {
                        requestedOfficerIds[req.officer_table_name].add(id);
                    }
                });
                console.log('üîç Requested officer IDs:', {
                    presiding: Array.from(requestedOfficerIds.presiding),
                    ass_presiding: Array.from(requestedOfficerIds.ass_presiding),
                    polling: Array.from(requestedOfficerIds.polling)
                });
                
                // Fetch all required data
                console.log('üìä Fetching vote centres...');
                const { data: voteCentres, error: centreError } = await window.supabaseClient
                    .from('vote_centre')
                    .select('*')
                    .order('vote_centre_code');
                
                if (centreError) {
                    console.error('‚ùå Vote Centre Error:', centreError);
                    throw new Error(`Vote Centre Error: ${centreError.message}`);
                }
                
                if (!voteCentres || voteCentres.length === 0) {
                    throw new Error('‡¶ï‡ßã‡¶® ‡¶≠‡ßã‡¶ü ‡¶ï‡ßá‡¶®‡ßç‡¶¶‡ßç‡¶∞ ‡¶™‡¶æ‡¶ì‡¶Ø‡¶º‡¶æ ‡¶Ø‡¶æ‡¶Ø‡¶º‡¶®‡¶ø! vote_centre ‡¶ü‡ßá‡¶¨‡¶ø‡¶≤‡ßá ‡¶°‡ßá‡¶ü‡¶æ ‡¶Ü‡¶õ‡ßá ‡¶ï‡¶ø‡¶®‡¶æ ‡¶ö‡ßá‡¶ï ‡¶ï‡¶∞‡ßÅ‡¶®‡•§');
                }
                
                console.log(`‚úÖ Found ${voteCentres.length} vote centres`);
                
                // Fetch all presiding list with pagination (no filter here)
                console.log('üìä Fetching presiding list with pagination...');
                const presidingListAll = await fetchAllData('presiding_list', 'presiding_iid');
                
                if (!presidingListAll || presidingListAll.length === 0) {
                    throw new Error('‡¶ï‡ßã‡¶® ‡¶™‡ßç‡¶∞‡¶ø‡¶∏‡¶æ‡¶á‡¶°‡¶ø‡¶Ç ‡¶Ö‡¶´‡¶ø‡¶∏‡¶æ‡¶∞ ‡¶™‡¶æ‡¶ì‡¶Ø‡¶º‡¶æ ‡¶Ø‡¶æ‡¶Ø‡¶º‡¶®‡¶ø!');
                }

                const presidingEligible = presidingListAll.filter(p => !isDisabled(p));
                
                // Fetch all assistant presiding list with pagination (no filter here)
                console.log('üìä Fetching assistant presiding list with pagination...');
                const assPresidingListAll = await fetchAllData('ass_presiding_list', 'ass_presiding_iid');
                
                if (!assPresidingListAll || assPresidingListAll.length === 0) {
                    throw new Error('‡¶ï‡ßã‡¶® ‡¶∏‡¶π‡¶ï‡¶æ‡¶∞‡ßÄ ‡¶™‡ßç‡¶∞‡¶ø‡¶∏‡¶æ‡¶á‡¶°‡¶ø‡¶Ç ‡¶Ö‡¶´‡¶ø‡¶∏‡¶æ‡¶∞ ‡¶™‡¶æ‡¶ì‡¶Ø‡¶º‡¶æ ‡¶Ø‡¶æ‡¶Ø‡¶º‡¶®‡¶ø!');
                }

                const assPresidingEligible = assPresidingListAll.filter(p => !isDisabled(p));
                
                // Fetch all polling list with pagination (no filter here)
                console.log('üìä Fetching polling list with pagination...');
                const pollingListAll = await fetchAllData('polling_list', 'polling_iid');
                
                console.log(`üìä Total polling officers loaded: ${pollingListAll.length}`);
                
                const pollingEligible = pollingListAll.filter(p => {
                    return p.polling_name && p.polling_name.trim() !== '' && !isDisabled(p);
                });

                if (!pollingEligible || pollingEligible.length === 0) {
                    throw new Error('‡¶ï‡ßã‡¶® ‡¶™‡ßã‡¶≤‡¶ø‡¶Ç ‡¶Ö‡¶´‡¶ø‡¶∏‡¶æ‡¶∞ ‡¶™‡¶æ‡¶ì‡¶Ø‡¶º‡¶æ ‡¶Ø‡¶æ‡¶Ø‡¶º‡¶®‡¶ø!');
                }

                // Process request_table officers (disability filter only, assign_code ignored)
                console.log('üîç Processing request_table officers (disability filtered only)...');
                const requestedPresidingByCentre = new Map();
                const requestedAssPresidingByCentre = new Map();
                const requestedPollingByCentre = new Map();

                function addRequested(map, centreIid, officer) {
                    if (!map.has(centreIid)) {
                        map.set(centreIid, []);
                    }
                    map.get(centreIid).push(officer);
                }

                requestData.forEach(req => {
                    const centreIid = normalizeId(req.vote_centre_iid);
                    const officerId = normalizeId(req.officer_table_iid);
                    const tableName = req.officer_table_name;

                    if (!centreIid || !officerId || !tableName) return;

                    let sourceAll = null;
                    let idKey = '';
                    let targetMap = null;

                    if (tableName === 'presiding') {
                        sourceAll = presidingListAll;
                        idKey = 'presiding_iid';
                        targetMap = requestedPresidingByCentre;
                    } else if (tableName === 'ass_presiding') {
                        sourceAll = assPresidingListAll;
                        idKey = 'ass_presiding_iid';
                        targetMap = requestedAssPresidingByCentre;
                    } else if (tableName === 'polling') {
                        sourceAll = pollingListAll;
                        idKey = 'polling_iid';
                        targetMap = requestedPollingByCentre;
                    } else {
                        return;
                    }

                    const rawOfficer = sourceAll.find(p => normalizeId(p[idKey]) === officerId);
                    if (!rawOfficer) {
                        console.log(`   ‚ùå Requested ${tableName} ID ${officerId} not found in ${tableName}_list`);
                        return;
                    }

                    if (isDisabled(rawOfficer)) {
                        console.log(`   ‚ö†Ô∏è Requested ${tableName} ID ${officerId} excluded (disability=Yes)`);
                        return;
                    }

                    addRequested(targetMap, centreIid, rawOfficer);
                });

                console.log(`üìä Requested (eligible) presiding centres: ${requestedPresidingByCentre.size}`);
                console.log(`üìä Requested (eligible) ass_presiding centres: ${requestedAssPresidingByCentre.size}`);
                console.log(`üìä Requested (eligible) polling centres: ${requestedPollingByCentre.size}`);

                // Build requested ID sets for pool exclusion
                const requestedPresidingIds = new Set();
                const requestedAssPresidingIds = new Set();
                const requestedPollingIds = new Set();

                requestedPresidingByCentre.forEach(list => {
                    list.forEach(o => requestedPresidingIds.add(normalizeId(o.presiding_iid)));
                });
                requestedAssPresidingByCentre.forEach(list => {
                    list.forEach(o => requestedAssPresidingIds.add(normalizeId(o.ass_presiding_iid)));
                });
                requestedPollingByCentre.forEach(list => {
                    list.forEach(o => requestedPollingIds.add(normalizeId(o.polling_iid)));
                });

                // Build available pools (exclude disability, assigned, and requested IDs)
                const presidingAvailable = shuffleArray(
                    presidingEligible.filter(p => !isAssigned(p) && !requestedPresidingIds.has(normalizeId(p.presiding_iid)))
                );
                const assPresidingAvailableRaw = assPresidingEligible.filter(
                    p => !isAssigned(p) && !requestedAssPresidingIds.has(normalizeId(p.ass_presiding_iid))
                );
                const pollingAvailableRaw = pollingEligible.filter(
                    p => !isAssigned(p) && !requestedPollingIds.has(normalizeId(p.polling_iid))
                );

                const assPresidingAvailable = shuffleWithGenderBalance(assPresidingAvailableRaw);
                const pollingAvailable = shuffleWithGenderBalance(pollingAvailableRaw);
                
                // Calculate required officers
                let totalBooths = 0;
                voteCentres.forEach(c => totalBooths += (c.voter_both_total || 0));
                
                const required = {
                    presiding: voteCentres.length,
                    assPresiding: totalBooths,
                    polling: totalBooths * 2
                };

                const availableCounts = {
                    presiding: presidingAvailable.length + requestedPresidingIds.size,
                    assPresiding: assPresidingAvailable.length + requestedAssPresidingIds.size,
                    polling: pollingAvailable.length + requestedPollingIds.size
                };
                
                console.log('üìä Requirements:', required);
                console.log(`   Presiding: ${availableCounts.presiding}/${required.presiding}`);
                console.log(`   Ass Presiding: ${availableCounts.assPresiding}/${required.assPresiding}`);
                console.log(`   Polling: ${availableCounts.polling}/${required.polling}`);
                
                // Check availability and calculate how many centres we can assign
                const canAssignCentres = Math.min(
                    availableCounts.presiding,
                    voteCentres.length
                );
                
                let warnings = [];
                if (availableCounts.presiding < required.presiding) {
                    warnings.push(`‚ö†Ô∏è ‡¶™‡ßç‡¶∞‡¶ø‡¶∏‡¶æ‡¶á‡¶°‡¶ø‡¶Ç: ${availableCounts.presiding}/${required.presiding} ‡¶ú‡¶® (${required.presiding - availableCounts.presiding} ‡¶ú‡¶® ‡¶ï‡¶Æ)`);
                }
                if (availableCounts.assPresiding < required.assPresiding) {
                    warnings.push(`‚ö†Ô∏è ‡¶∏‡¶π‡¶ï‡¶æ‡¶∞‡ßÄ ‡¶™‡ßç‡¶∞‡¶ø‡¶∏‡¶æ‡¶á‡¶°‡¶ø‡¶Ç: ${availableCounts.assPresiding}/${required.assPresiding} ‡¶ú‡¶® (${required.assPresiding - availableCounts.assPresiding} ‡¶ú‡¶® ‡¶ï‡¶Æ)`);
                }
                if (availableCounts.polling < required.polling) {
                    warnings.push(`‚ö†Ô∏è ‡¶™‡ßã‡¶≤‡¶ø‡¶Ç: ${availableCounts.polling}/${required.polling} ‡¶ú‡¶® (${required.polling - availableCounts.polling} ‡¶ú‡¶® ‡¶ï‡¶Æ)`);
                }
                
                if (warnings.length > 0) {
                    console.log('‚ö†Ô∏è Officer shortage detected:');
                    warnings.forEach(w => console.log(`   ${w}`));
                    showStatus(`‚ö†Ô∏è ‡¶Ø‡¶•‡ßá‡¶∑‡ßç‡¶ü ‡¶Ö‡¶´‡¶ø‡¶∏‡¶æ‡¶∞ ‡¶®‡ßá‡¶á! ‡¶∂‡ßÅ‡¶ß‡ßÅ ${canAssignCentres} ‡¶ü‡¶ø ‡¶ï‡ßá‡¶®‡ßç‡¶¶‡ßç‡¶∞‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶¨‡¶®‡ßç‡¶ü‡¶® ‡¶ï‡¶∞‡¶æ ‡¶π‡¶¨‡ßá‡•§\n${warnings.join('\n')}`, 'error');
                }
                
                console.log(`‚úÖ Starting assignment for ${canAssignCentres} centres...`);
                
                // Reorder centres: requested centres first, then others
                const centresWithRequests = [];
                const centresWithoutRequests = [];
                
                voteCentres.forEach(centre => {
                    const centreIid = String(centre.vote_centre_iid || '').trim();
                    if (requestByCentreIid.has(centreIid)) {
                        centresWithRequests.push(centre);
                    } else {
                        centresWithoutRequests.push(centre);
                    }
                });
                
                const orderedCentres = [...centresWithRequests, ...centresWithoutRequests];
                console.log(`üìã Reordered centres: ${centresWithRequests.length} with requests first, then ${centresWithoutRequests.length} others`);
                
                let skippedCentres = [];
                let assignedCount = 0;
                const usedRequestedIds = {
                    presiding: new Set(),
                    ass_presiding: new Set(),
                    polling: new Set()
                };
                
                // Process each vote centre (now in priority order)
                for (const centre of orderedCentres) {
                    const boothCount = centre.voter_both_total || 0;
                    
                    if (boothCount === 0) continue;
                    
                    const centreIidStr = normalizeId(centre.vote_centre_iid);
                    const centreRequests = requestByCentreIid.get(centreIidStr) || [];

                    const requestedPresidingForCentre = (requestedPresidingByCentre.get(centreIidStr) || [])
                        .filter(p => !usedRequestedIds.presiding.has(normalizeId(p.presiding_iid)));
                    const requestedAssPresidingForCentre = (requestedAssPresidingByCentre.get(centreIidStr) || [])
                        .filter(p => !usedRequestedIds.ass_presiding.has(normalizeId(p.ass_presiding_iid)));
                    const requestedPollingForCentre = (requestedPollingByCentre.get(centreIidStr) || [])
                        .filter(p => !usedRequestedIds.polling.has(normalizeId(p.polling_iid)));

                    if (centreRequests.length > 0) {
                        console.log(`üéØ Centre ${centre.vote_centre_code} (IID: ${centreIidStr}) has ${centreRequests.length} request_table entries`);
                    }

                    const assPresidingNeeded = boothCount;
                    const pollingNeeded = boothCount * 2;

                    const remainingPresidingNeeded = requestedPresidingForCentre.length > 0 ? 0 : 1;
                    const remainingAssPresidingNeeded = Math.max(0, assPresidingNeeded - requestedAssPresidingForCentre.length);
                    const remainingPollingNeeded = Math.max(0, pollingNeeded - requestedPollingForCentre.length);

                    // Check if we have enough officers for this centre
                    if (remainingPresidingNeeded > 0 && presidingAvailable.length === 0) {
                        console.log(`‚ö†Ô∏è Skipping centre ${centre.vote_centre_code} - no presiding officer`);
                        skippedCentres.push(`‡¶ï‡ßá‡¶®‡ßç‡¶¶‡ßç‡¶∞ ${centre.vote_centre_code} (‡¶™‡ßç‡¶∞‡¶ø‡¶∏‡¶æ‡¶á‡¶°‡¶ø‡¶Ç ‡¶Ö‡¶´‡¶ø‡¶∏‡¶æ‡¶∞ ‡¶®‡ßá‡¶á)`);
                        continue;
                    }
                    if (assPresidingAvailable.length < remainingAssPresidingNeeded) {
                        console.log(`‚ö†Ô∏è Skipping centre ${centre.vote_centre_code} - not enough ass presiding`);
                        skippedCentres.push(`‡¶ï‡ßá‡¶®‡ßç‡¶¶‡ßç‡¶∞ ${centre.vote_centre_code} (‡¶∏‡¶π‡¶ï‡¶æ‡¶∞‡ßÄ ‡¶™‡ßç‡¶∞‡¶ø‡¶∏‡¶æ‡¶á‡¶°‡¶ø‡¶Ç ‡¶ï‡¶Æ)`);
                        continue;
                    }
                    if (pollingAvailable.length < remainingPollingNeeded) {
                        console.log(`‚ö†Ô∏è Skipping centre ${centre.vote_centre_code} - not enough polling`);
                        skippedCentres.push(`‡¶ï‡ßá‡¶®‡ßç‡¶¶‡ßç‡¶∞ ${centre.vote_centre_code} (‡¶™‡ßã‡¶≤‡¶ø‡¶Ç ‡¶Ö‡¶´‡¶ø‡¶∏‡¶æ‡¶∞ ‡¶ï‡¶Æ)`);
                        continue;
                    }

                    // Assign presiding officer (priority to request_table)
                    let presiding = null;
                    if (requestedPresidingForCentre.length > 0) {
                        if (requestedPresidingForCentre.length > 1) {
                            console.log(`‚ö†Ô∏è Centre ${centre.vote_centre_code} has multiple requested presiding officers, using the first one`);
                        }
                        presiding = requestedPresidingForCentre[0];
                        usedRequestedIds.presiding.add(normalizeId(presiding.presiding_iid));
                        console.log(`‚úÖ Using requested presiding ${presiding.presiding_iid} (${presiding.presiding_name}) for centre ${centre.vote_centre_code}`);
                    } else {
                        presiding = presidingAvailable.shift();
                    }

                    // Assign assistant presiding officers (requested first)
                    let assPresidingForCentre = [];
                    const requestedAssToUse = requestedAssPresidingForCentre.slice(0, assPresidingNeeded);
                    if (requestedAssPresidingForCentre.length > assPresidingNeeded) {
                        console.log(`‚ö†Ô∏è Centre ${centre.vote_centre_code} has ${requestedAssPresidingForCentre.length - assPresidingNeeded} extra requested ass_presiding officers (not enough booths)`);
                    }

                    requestedAssToUse.forEach(o => {
                        assPresidingForCentre.push(o);
                        usedRequestedIds.ass_presiding.add(normalizeId(o.ass_presiding_iid));
                    });

                    while (assPresidingForCentre.length < assPresidingNeeded) {
                        assPresidingForCentre.push(assPresidingAvailable.shift());
                    }

                    // Assign polling officers (requested first)
                    let pollingForCentre = [];
                    const requestedPollingToUse = requestedPollingForCentre.slice(0, pollingNeeded);
                    if (requestedPollingForCentre.length > pollingNeeded) {
                        console.log(`‚ö†Ô∏è Centre ${centre.vote_centre_code} has ${requestedPollingForCentre.length - pollingNeeded} extra requested polling officers (not enough positions)`);
                    }

                    requestedPollingToUse.forEach(o => {
                        pollingForCentre.push(o);
                        usedRequestedIds.polling.add(normalizeId(o.polling_iid));
                    });

                    while (pollingForCentre.length < pollingNeeded) {
                        pollingForCentre.push(pollingAvailable.shift());
                    }
                    
                    // Create assignment object
                    const assignment = {
                        centre: centre,
                        presiding: presiding,
                        assPresiding: assPresidingForCentre,
                        polling: pollingForCentre
                    };
                    
                    generatedData.push(assignment);
                    assignedCount++;
                }
                
                console.log(`‚úÖ Successfully assigned ${generatedData.length} centres`);
                
                if (skippedCentres.length > 0) {
                    console.log(`‚ö†Ô∏è Skipped ${skippedCentres.length} centres:`, skippedCentres);
                }
                
                if (generatedData.length === 0) {
                    throw new Error('‡¶ï‡ßã‡¶® ‡¶ï‡ßá‡¶®‡ßç‡¶¶‡ßç‡¶∞‡ßá ‡¶¶‡¶æ‡¶Ø‡¶º‡¶ø‡¶§‡ßç‡¶¨ ‡¶¨‡¶®‡ßç‡¶ü‡¶® ‡¶π‡¶Ø‡¶º‡¶®‡¶ø! ‡¶Ö‡¶´‡¶ø‡¶∏‡¶æ‡¶∞ ‡¶∏‡¶Ç‡¶ñ‡ßç‡¶Ø‡¶æ ‡¶ö‡ßá‡¶ï ‡¶ï‡¶∞‡ßÅ‡¶®‡•§');
                }
                
                // Display results
                displayAssignments();
                
                // Show statistics
                displayStats();
                
                // Show save, regenerate and print buttons (always show regenerate for retry)
                document.getElementById('saveBtn').style.display = 'inline-block';
                document.getElementById('printBtn').style.display = 'inline-block';
                
                let successMsg = `‚úÖ ‡¶∏‡¶´‡¶≤‡¶≠‡¶æ‡¶¨‡ßá ${generatedData.length} ‡¶ü‡¶ø ‡¶ï‡ßá‡¶®‡ßç‡¶¶‡ßç‡¶∞‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶¶‡¶æ‡¶Ø‡¶º‡¶ø‡¶§‡ßç‡¶¨ ‡¶¨‡¶®‡ßç‡¶ü‡¶® ‡¶∏‡¶Æ‡ßç‡¶™‡¶®‡ßç‡¶® ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá!`;
                if (skippedCentres.length > 0) {
                    successMsg += ` ‚ö†Ô∏è ${skippedCentres.length} ‡¶ü‡¶ø ‡¶ï‡ßá‡¶®‡ßç‡¶¶‡ßç‡¶∞ skip ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá (‡¶Ø‡¶•‡ßá‡¶∑‡ßç‡¶ü ‡¶Ö‡¶´‡¶ø‡¶∏‡¶æ‡¶∞ ‡¶®‡ßá‡¶á)‡•§ ‡¶™‡¶õ‡¶®‡ßç‡¶¶ ‡¶®‡¶æ ‡¶π‡¶≤‡ßá '‡¶®‡¶§‡ßÅ‡¶® ‡¶ï‡¶∞‡ßá ‡¶¨‡¶®‡ßç‡¶ü‡¶® ‡¶ï‡¶∞‡ßÅ‡¶®' ‡¶ö‡¶æ‡¶™‡ßÅ‡¶®‡•§`;
                } else {
                    successMsg += ` ‡¶™‡¶õ‡¶®‡ßç‡¶¶ ‡¶®‡¶æ ‡¶π‡¶≤‡ßá '‡¶®‡¶§‡ßÅ‡¶® ‡¶ï‡¶∞‡ßá ‡¶¨‡¶®‡ßç‡¶ü‡¶® ‡¶ï‡¶∞‡ßÅ‡¶®' ‡¶ö‡¶æ‡¶™‡ßÅ‡¶®‡•§`;
                }
                
                showStatus(successMsg, skippedCentres.length > 0 ? 'error' : 'success');
                
            } catch (error) {
                console.error('‚ùå Error:', error);
                showStatus(`‚ùå ‡¶§‡ßç‡¶∞‡ßÅ‡¶ü‡¶ø: ${error.message}`, 'error');
                
                // Show detailed error in console
                if (error.details) console.error('Details:', error.details);
                if (error.hint) console.error('Hint:', error.hint);
            } finally {
                setLoading(false);
            }
        }
        
        // Display statistics
        function displayStats() {
            let totalPresiding = 0;
            let totalAssPresiding = 0;
            let totalPolling = 0;
            
            generatedData.forEach(assignment => {
                totalPresiding += 1;
                totalAssPresiding += assignment.assPresiding.length;
                totalPolling += assignment.polling.length;
            });
            
            const statsHTML = `
                <div class="stat-card">
                    <div class="stat-number">${generatedData.length}</div>
                    <div class="stat-label">‡¶Æ‡ßã‡¶ü ‡¶ï‡ßá‡¶®‡ßç‡¶¶‡ßç‡¶∞</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${totalPresiding}</div>
                    <div class="stat-label">‡¶™‡ßç‡¶∞‡¶ø‡¶∏‡¶æ‡¶á‡¶°‡¶ø‡¶Ç ‡¶Ö‡¶´‡¶ø‡¶∏‡¶æ‡¶∞</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${totalAssPresiding}</div>
                    <div class="stat-label">‡¶∏‡¶π‡¶ï‡¶æ‡¶∞‡ßÄ ‡¶™‡ßç‡¶∞‡¶ø‡¶∏‡¶æ‡¶á‡¶°‡¶ø‡¶Ç ‡¶Ö‡¶´‡¶ø‡¶∏‡¶æ‡¶∞</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${totalPolling}</div>
                    <div class="stat-label">‡¶™‡ßã‡¶≤‡¶ø‡¶Ç ‡¶Ö‡¶´‡¶ø‡¶∏‡¶æ‡¶∞</div>
                </div>
            `;
            
            const statsGrid = document.getElementById('statsGrid');
            statsGrid.innerHTML = statsHTML;
            statsGrid.style.display = 'grid';
        }
        
        // Display assignments
        function displayAssignments() {
            const container = document.getElementById('centresContainer');
            let html = '';
            
            generatedData.forEach((assignment, index) => {
                const centre = assignment.centre;
                const presiding = assignment.presiding;
                const assPresiding = assignment.assPresiding;
                const polling = assignment.polling;
                
                html += `
                    <div class="centre-card">
                        <div class="centre-header">
                            <p class="centre-meta">${[centre.vote_centre_area, centre.vote_centre_name].filter(Boolean).join(', ')}</p>
                            <h2>‡¶ï‡ßá‡¶®‡ßç‡¶¶‡ßç‡¶∞ ‡¶®‡¶Ç ‚Äì ${centre.vote_centre_code}</h2>
                            <p>‡¶Æ‡ßã‡¶ü ‡¶¨‡ßÅ‡¶•: ${centre.voter_both_total || 0}</p>
                        </div>
                        
                        <table class="assignment-table">
                            <thead>
                                <tr>
                                    <th>‡¶™‡ßç‡¶∞‡¶ø‡¶∏‡¶æ‡¶á‡¶°‡¶ø‡¶Ç ‡¶Ö‡¶´‡¶ø‡¶∏‡¶æ‡¶∞</th>
                                    <th>‡¶∏‡¶π‡¶ï‡¶æ‡¶∞‡ßÄ ‡¶™‡ßç‡¶∞‡¶ø‡¶∏‡¶æ‡¶á‡¶°‡¶ø‡¶Ç ‡¶Ö‡¶´‡¶ø‡¶∏‡¶æ‡¶∞</th>
                                    <th>‡¶™‡ßã‡¶≤‡¶ø‡¶Ç ‡¶Ö‡¶´‡¶ø‡¶∏‡¶æ‡¶∞</th>
                                    <th>‡¶¨‡¶ø‡¶ï‡¶≤‡ßç‡¶™ ‡¶™‡ßç‡¶∞‡¶ø‡¶∏‡¶æ‡¶á‡¶°‡¶ø‡¶Ç</th>
                                </tr>
                            </thead>
                            <tbody>
                `;
                
                const maxRows = Math.max(1, assPresiding.length);
                
                for (let i = 0; i < maxRows; i++) {
                    const assPres = assPresiding[i];
                    const poll1 = polling[i * 2];
                    const poll2 = polling[i * 2 + 1];
                    
                    html += `
                        <tr>
                            ${i === 0 ? `<td rowspan="${maxRows}" style="text-align:center; vertical-align:middle;">
                                ${presiding ? `
                                    <div class="officer-name">${getOfficerName(presiding, 'presiding')}</div>
                                    <div class="officer-designation">${presiding.designation || ''}</div>
                                ` : '<div class="officer-name">N/A</div>'}
                            </td>` : ''}
                            
                            <td style="text-align:center;">
                                ${assPres ? `
                                    <div class="officer-name">${getOfficerName(assPres, 'ass_presiding')}</div>
                                    <div class="officer-designation">${assPres.designation || ''}</div>
                                    <div class="officer-designation">${assPres.gender || ''}</div>
                                ` : ''}
                            </td>
                            
                            <td>
                                ${poll1 ? `
                                    <div class="officer-name">‡ßß. ${getOfficerName(poll1, 'polling')}</div>
                                    <div class="officer-designation">${poll1.designation || ''} (${poll1.gender || ''})</div>
                                ` : ''}
                                ${poll2 ? `
                                    <div class="officer-name">‡ß®. ${getOfficerName(poll2, 'polling')}</div>
                                    <div class="officer-designation">${poll2.designation || ''} (${poll2.gender || ''})</div>
                                ` : ''}
                            </td>
                            
                            ${i === 0 ? `<td rowspan="${maxRows}" style="text-align:center; vertical-align:middle;">
                                ${assPresiding[0] ? `
                                    <div class="officer-name">${getOfficerName(assPresiding[0], 'ass_presiding')}</div>
                                    <div class="officer-designation">${assPresiding[0].designation || ''}</div>
                                ` : '<div class="officer-name">N/A</div>'}
                            </td>` : ''}
                        </tr>
                    `;
                }
                
                html += `
                            </tbody>
                        </table>
                    </div>
                `;
            });
            
            container.innerHTML = html;
        }
        
        // Load assignments from database
        async function loadFromDatabase() {
            setLoading(true);
            generatedData = [];
            document.getElementById('centresContainer').innerHTML = '';
            document.getElementById('statsGrid').style.display = 'none';
            showStatus('üìÇ ‡¶°‡¶æ‡¶ü‡¶æ‡¶¨‡ßá‡¶∏ ‡¶•‡ßá‡¶ï‡ßá ‡¶°‡ßá‡¶ü‡¶æ ‡¶≤‡ßã‡¶° ‡¶ï‡¶∞‡¶æ ‡¶π‡¶ö‡ßç‡¶õ‡ßá...', 'info');
            
            try {
                console.log('üîç Loading data from database...');
                
                // Check Supabase connection
                if (!window.supabaseClient) {
                    throw new Error('Supabase client not initialized. Please check authentication.js');
                }
                
                // Fetch all assignments from database with timeout
                // Paginate centre_assignments to bypass 1000 row limit
                console.log('üìä Fetching assignments with pagination...');
                async function fetchAllAssignments() {
                    let all = [];
                    let lastId = 0;
                    const batchSize = 1000;
                    let batch = 0;
                    while (true) {
                        batch++;
                        const { data, error } = await window.supabaseClient
                            .from('centre_assignments')
                            .select('*')
                            .gt('assignment_id', lastId)
                            .order('assignment_id', { ascending: true })
                            .limit(batchSize);
                        if (error) {
                            console.error('‚ùå Database error:', error);
                            throw new Error(`‡¶°‡ßá‡¶ü‡¶æ ‡¶≤‡ßã‡¶° ‡¶ï‡¶∞‡¶§‡ßá ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ: ${error.message}`);
                        }
                        const size = data ? data.length : 0;
                        console.log(`   Batch ${batch}: ${size} rows`);
                        if (!data || size === 0) break;
                        all.push(...data);
                        lastId = data[data.length - 1].assignment_id;
                        if (size < batchSize) break;
                    }
                    return all;
                }

                const assignments = await fetchAllAssignments();
                console.log(`‚úÖ Fetched ${assignments.length} assignment records (all pages)`);
                
                if (!assignments || assignments.length === 0) {
                    console.log('‚ö†Ô∏è No saved assignments found in database');
                    showStatus('‚ö†Ô∏è ‡¶°‡¶æ‡¶ü‡¶æ‡¶¨‡ßá‡¶∏‡ßá ‡¶ï‡ßã‡¶® ‡¶∏‡¶Ç‡¶∞‡¶ï‡ßç‡¶∑‡¶ø‡¶§ ‡¶¶‡¶æ‡¶Ø‡¶º‡¶ø‡¶§‡ßç‡¶¨ ‡¶¨‡¶®‡ßç‡¶ü‡¶® ‡¶®‡ßá‡¶á! "‡¶®‡¶§‡ßÅ‡¶® ‡¶ï‡¶∞‡ßá ‡¶¨‡¶®‡ßç‡¶ü‡¶® ‡¶ï‡¶∞‡ßÅ‡¶®" ‡¶ï‡ßç‡¶≤‡¶ø‡¶ï ‡¶ï‡¶∞‡ßÅ‡¶®‡•§', 'error');
                    document.getElementById('saveBtn').style.display = 'none';
                    setLoading(false);
                    return;
                }
                
                console.log('üì¶ Processing assignment data...');
                // Fetch vote centre details for all centres present in the assignments so we can include name & area
                const centreIidSet = new Set(assignments.map(a => a.vote_centre_iid));
                const centreIids = Array.from(centreIidSet);
                const centreInfoMap = new Map();
                if (centreIids.length > 0) {
                    const { data: centreInfos, error: centreInfoError } = await window.supabaseClient
                        .from('vote_centre')
                        .select('vote_centre_iid, vote_centre_code, vote_centre_name, vote_centre_area, voter_both_total')
                        .in('vote_centre_iid', centreIids);
                    if (centreInfoError) {
                        console.warn('‚ö†Ô∏è Could not fetch vote centre info:', centreInfoError);
                    } else if (centreInfos && centreInfos.length > 0) {
                        centreInfos.forEach(c => centreInfoMap.set(String(c.vote_centre_iid), c));
                    }
                }

                // Group assignments by vote centre
                const centreMap = new Map();
                
                for (const assignment of assignments) {
                    const centreCode = assignment.vote_centre_code;
                    
                    if (!centreMap.has(centreCode)) {
                        const centreInfo = centreInfoMap.get(String(assignment.vote_centre_iid)) || {};
                        centreMap.set(centreCode, {
                            centre: {
                                vote_centre_code: assignment.vote_centre_code,
                                vote_centre_iid: assignment.vote_centre_iid,
                                vote_centre_name: centreInfo.vote_centre_name || '',
                                vote_centre_area: centreInfo.vote_centre_area || '',
                                voter_both_total: centreInfo.voter_both_total || 0
                            },
                            presiding: null,
                            assPresiding: [],
                            polling: []
                        });
                    }
                    
                    const centreData = centreMap.get(centreCode);
                    
                    if (assignment.officer_type === 'presiding') {
                        centreData.presiding = {
                            presiding_name: assignment.officer_name,
                            designation: assignment.officer_designation
                        };
                    } else if (assignment.officer_type === 'ass_presiding') {
                        centreData.assPresiding.push({
                            ass_presiding_name: assignment.officer_name,
                            designation: assignment.officer_designation,
                            gender: assignment.officer_gender,
                            booth_number: assignment.booth_number
                        });
                        centreData.centre.voter_both_total = Math.max(
                            centreData.centre.voter_both_total,
                            assignment.booth_number || 0
                        );
                    } else if (assignment.officer_type === 'polling') {
                        centreData.polling.push({
                            polling_name: assignment.officer_name,
                            designation: assignment.officer_designation,
                            gender: assignment.officer_gender,
                            booth_number: assignment.booth_number,
                            person_number: assignment.person_number
                        });
                    }
                }
                
                // Convert map to array
                generatedData = Array.from(centreMap.values());
                
                console.log(`‚úÖ Processed ${generatedData.length} centres`);
                
                // Sort assPresiding and polling by booth/person number
                generatedData.forEach(data => {
                    data.assPresiding.sort((a, b) => a.booth_number - b.booth_number);
                    data.polling.sort((a, b) => {
                        if (a.booth_number !== b.booth_number) {
                            return a.booth_number - b.booth_number;
                        }
                        return a.person_number - b.person_number;
                    });
                });
                
                console.log('üé® Displaying assignments...');
                // Display the loaded data
                displayAssignments();
                displayStats();
                
                console.log('‚úÖ Load complete!');
                
                // Hide save button (already saved), show print button
                document.getElementById('saveBtn').style.display = 'none';
                document.getElementById('printBtn').style.display = 'inline-block';
                
                showStatus(`‚úÖ ‡¶∏‡¶´‡¶≤‡¶≠‡¶æ‡¶¨‡ßá ${generatedData.length} ‡¶ü‡¶ø ‡¶ï‡ßá‡¶®‡ßç‡¶¶‡ßç‡¶∞‡ßá‡¶∞ ‡¶¶‡¶æ‡¶Ø‡¶º‡¶ø‡¶§‡ßç‡¶¨ ‡¶¨‡¶®‡ßç‡¶ü‡¶® ‡¶≤‡ßã‡¶° ‡¶ï‡¶∞‡¶æ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá!`, 'success');
                
            } catch (error) {
                console.error('Load error:', error);
                showStatus(`‚ùå ‡¶≤‡ßã‡¶° ‡¶ï‡¶∞‡¶§‡ßá ‡¶§‡ßç‡¶∞‡ßÅ‡¶ü‡¶ø: ${error.message}`, 'error');
            } finally {
                setLoading(false);
            }
        }
        
        // Regenerate assignments (clear and generate again)
        async function regenerateAssignments() {
            if (!confirm('‡¶Ü‡¶™‡¶®‡¶ø ‡¶ï‡¶ø ‡¶®‡¶ø‡¶∂‡ßç‡¶ö‡¶ø‡¶§ ‡¶Ø‡ßá ‡¶Ü‡¶¨‡¶æ‡¶∞ ‡¶®‡¶§‡ßÅ‡¶® ‡¶ï‡¶∞‡ßá ‡¶¶‡¶æ‡¶Ø‡¶º‡¶ø‡¶§‡ßç‡¶¨ ‡¶¨‡¶®‡ßç‡¶ü‡¶® ‡¶ï‡¶∞‡¶§‡ßá ‡¶ö‡¶æ‡¶®? ‡¶™‡ßÅ‡¶∞‡¶æ‡¶®‡ßã ‡¶°‡ßá‡¶ü‡¶æ ‡¶Æ‡ßÅ‡¶õ‡ßá ‡¶®‡¶§‡ßÅ‡¶® ‡¶ï‡¶∞‡ßá ‡¶¨‡¶®‡ßç‡¶ü‡¶® ‡¶π‡¶¨‡ßá‡•§')) {
                return;
            }
            
            setLoading(true);
            showStatus('üîÑ ‡¶™‡ßÅ‡¶∞‡¶æ‡¶®‡ßã ‡¶°‡ßá‡¶ü‡¶æ ‡¶∞‡¶ø‡¶∏‡ßá‡¶ü ‡¶ï‡¶∞‡¶æ ‡¶π‡¶ö‡ßç‡¶õ‡ßá...', 'info');
            
            try {
                // Delete all old assignments from database
                console.log('üóëÔ∏è Deleting old assignments from database...');
                
                const { error: deleteError } = await window.supabaseClient
                    .from('centre_assignments')
                    .delete()
                    .neq('assignment_id', 0); // Delete all records
                
                if (deleteError) {
                    console.error('Delete error:', deleteError);
                    throw new Error(`‡¶™‡ßÅ‡¶∞‡¶æ‡¶§‡¶® ‡¶°‡ßá‡¶ü‡¶æ ‡¶°‡¶ø‡¶≤‡¶ø‡¶ü ‡¶ï‡¶∞‡¶§‡ßá ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ: ${deleteError.message}`);
                }
                
                console.log('‚úÖ Old assignments deleted from database');
                
                // Reset assign_code in all officer tables
                console.log('üîÑ Resetting assign_code in officer tables...');
                
                await window.supabaseClient
                    .from('presiding_list')
                    .update({ assign_code: null })
                    .neq('presiding_iid', 0);
                
                await window.supabaseClient
                    .from('ass_presiding_list')
                    .update({ assign_code: null })
                    .neq('ass_presiding_iid', 0);
                
                await window.supabaseClient
                    .from('polling_list')
                    .update({ assign_code: null })
                    .neq('polling_iid', 0);
                
                console.log('‚úÖ All assign_code reset in database');
                
                // Reset UI
                document.getElementById('saveBtn').style.display = 'none';
                document.getElementById('centresContainer').innerHTML = '';
                document.getElementById('statsGrid').style.display = 'none';
                generatedData = [];
                
                showStatus('‚úÖ ‡¶°‡ßá‡¶ü‡¶æ ‡¶∞‡¶ø‡¶∏‡ßá‡¶ü ‡¶∏‡¶Æ‡ßç‡¶™‡¶®‡ßç‡¶®! ‡¶®‡¶§‡ßÅ‡¶® ‡¶ï‡¶∞‡ßá ‡¶ú‡ßá‡¶®‡¶æ‡¶∞‡ßá‡¶ü ‡¶ï‡¶∞‡¶æ ‡¶π‡¶ö‡ßç‡¶õ‡ßá...', 'success');
                
                // Generate new assignments
                await generateAssignments();
                
            } catch (error) {
                console.error('‚ùå Regenerate Error:', error);
                showStatus(`‚ùå ‡¶∞‡¶ø‡¶ú‡ßá‡¶®‡¶æ‡¶∞‡ßá‡¶ü ‡¶ï‡¶∞‡¶§‡ßá ‡¶§‡ßç‡¶∞‡ßÅ‡¶ü‡¶ø: ${error.message}`, 'error');
            } finally {
                setLoading(false);
            }
        }
        
        // Save assignments to database
        async function saveAssignments() {
            if (generatedData.length === 0) {
                showStatus('‚ö†Ô∏è ‡¶ï‡ßã‡¶® ‡¶°‡ßá‡¶ü‡¶æ ‡¶∏‡¶Ç‡¶∞‡¶ï‡ßç‡¶∑‡¶£‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶®‡ßá‡¶á!', 'error');
                return;
            }
            
            if (!confirm('‡¶Ü‡¶™‡¶®‡¶ø ‡¶ï‡¶ø ‡¶®‡¶ø‡¶∂‡ßç‡¶ö‡¶ø‡¶§ ‡¶Ø‡ßá ‡¶è‡¶á ‡¶¶‡¶æ‡¶Ø‡¶º‡¶ø‡¶§‡ßç‡¶¨ ‡¶¨‡¶®‡ßç‡¶ü‡¶® ‡¶∏‡¶Ç‡¶∞‡¶ï‡ßç‡¶∑‡¶£ ‡¶ï‡¶∞‡¶§‡ßá ‡¶ö‡¶æ‡¶®?')) {
                return;
            }
            
            setLoading(true);
            
            try {
                // Delete all old assignments first
                console.log('üóëÔ∏è Deleting old assignments...');
                
                // Delete from centre_assignments table
                const { error: deleteError } = await window.supabaseClient
                    .from('centre_assignments')
                    .delete()
                    .neq('assignment_id', 0); // Delete all records
                
                if (deleteError) {
                    console.error('Delete error:', deleteError);
                    throw new Error(`‡¶™‡ßÅ‡¶∞‡¶æ‡¶§‡¶® ‡¶°‡ßá‡¶ü‡¶æ ‡¶°‡¶ø‡¶≤‡¶ø‡¶ü ‡¶ï‡¶∞‡¶§‡ßá ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ: ${deleteError.message}`);
                }
                
                console.log('‚úÖ Old assignments deleted');
                
                // Reset assign_code in all officer tables
                console.log('üîÑ Resetting assign_code in officer tables...');
                
                await window.supabaseClient
                    .from('presiding_list')
                    .update({ assign_code: null })
                    .neq('presiding_iid', 0);
                
                await window.supabaseClient
                    .from('ass_presiding_list')
                    .update({ assign_code: null })
                    .neq('ass_presiding_iid', 0);
                
                await window.supabaseClient
                    .from('polling_list')
                    .update({ assign_code: null })
                    .neq('polling_iid', 0);
                
                console.log('‚úÖ All assign_code reset');
                
                console.log('üìù Building assignments to save...');
                const assignmentsToSave = [];
                
                generatedData.forEach(assignment => {
                    const centreCode = assignment.centre.vote_centre_code;
                    const centreId = assignment.centre.vote_centre_iid;
                    
                    // Presiding assignment
                    assignmentsToSave.push({
                        vote_centre_iid: centreId,
                        vote_centre_code: centreCode,
                        officer_type: 'presiding',
                        officer_iid: assignment.presiding.presiding_iid,
                        officer_name: getOfficerName(assignment.presiding, 'presiding'),
                        officer_designation: assignment.presiding.designation,
                        booth_number: null,
                        assign_code: `${centreId}`,
                        created_at: new Date().toISOString()
                    });
                    
                    // Assistant presiding assignments
                    assignment.assPresiding.forEach((assPres, index) => {
                        const boothNum = index + 1;
                        assignmentsToSave.push({
                            vote_centre_iid: centreId,
                            vote_centre_code: centreCode,
                            officer_type: 'ass_presiding',
                            officer_iid: assPres.ass_presiding_iid,
                            officer_name: getOfficerName(assPres, 'ass_presiding'),
                            officer_designation: assPres.designation,
                            officer_gender: assPres.gender,
                            booth_number: boothNum,
                            assign_code: `${centreId}-${boothNum}`,
                            created_at: new Date().toISOString()
                        });
                    });
                    
                    // Polling assignments
                    assignment.polling.forEach((poll, index) => {
                        const boothNum = Math.floor(index / 2) + 1;
                        const personNum = (index % 2) + 1;
                        assignmentsToSave.push({
                            vote_centre_iid: centreId,
                            vote_centre_code: centreCode,
                            officer_type: 'polling',
                            officer_iid: poll.polling_iid,
                            officer_name: getOfficerName(poll, 'polling'),
                            officer_designation: poll.designation,
                            officer_gender: poll.gender,
                            booth_number: boothNum,
                            person_number: personNum,
                            assign_code: `${centreId}-${boothNum}-${personNum}`,
                            created_at: new Date().toISOString()
                        });
                    });
                });
                
                console.log(`üìä Total assignments to save: ${assignmentsToSave.length}`);
                
                // Save to centre_assignments table
                console.log('üíæ Saving to centre_assignments table...');
                const { error: saveError } = await window.supabaseClient
                    .from('centre_assignments')
                    .insert(assignmentsToSave);
                
                if (saveError) {
                    console.error('‚ùå Save error:', saveError);
                    throw saveError;
                }
                
                console.log('‚úÖ Saved to centre_assignments table');
                
                // Update assign_code in respective tables (batch upsert to reduce round trips)
                console.log('üîÑ Updating assign_code in officer tables (batch upsert)...');
                
                const presidingUpdates = [];
                const assPresidingUpdates = [];
                const pollingUpdates = [];
                
                for (const assignment of generatedData) {
                    const centreId = assignment.centre.vote_centre_iid;
                    
                    if (assignment.presiding && assignment.presiding.presiding_iid) {
                        presidingUpdates.push({ presiding_iid: assignment.presiding.presiding_iid, assign_code: `${centreId}` });
                    }
                    
                    for (let i = 0; i < assignment.assPresiding.length; i++) {
                        const ap = assignment.assPresiding[i];
                        if (ap && ap.ass_presiding_iid) {
                            assPresidingUpdates.push({ ass_presiding_iid: ap.ass_presiding_iid, assign_code: `${centreId}-${i + 1}` });
                        }
                    }
                    
                    for (let i = 0; i < assignment.polling.length; i++) {
                        const poll = assignment.polling[i];
                        if (poll && poll.polling_iid) {
                            const boothNum = Math.floor(i / 2) + 1;
                            const personNum = (i % 2) + 1;
                            pollingUpdates.push({ polling_iid: poll.polling_iid, assign_code: `${centreId}-${boothNum}-${personNum}` });
                        }
                    }
                }

                // Deduplicate by key to avoid ON CONFLICT double-hit errors
                function dedupeByKey(rows, key) {
                    const map = new Map();
                    for (const row of rows) {
                        if (row && row[key] !== undefined && row[key] !== null) {
                            map.set(row[key], row); // last one wins
                        }
                    }
                    return Array.from(map.values());
                }

                const presidingUnique = dedupeByKey(presidingUpdates, 'presiding_iid');
                const assPresidingUnique = dedupeByKey(assPresidingUpdates, 'ass_presiding_iid');
                const pollingUnique = dedupeByKey(pollingUpdates, 'polling_iid');
                
                console.log(`   Presiding updates: ${presidingUnique.length} (raw ${presidingUpdates.length})`);
                console.log(`   Ass Presiding updates: ${assPresidingUnique.length} (raw ${assPresidingUpdates.length})`);
                console.log(`   Polling updates: ${pollingUnique.length} (raw ${pollingUpdates.length})`);
                
                async function batchUpsert(tableName, key, rows, chunkSize = 300) {
                    for (let i = 0; i < rows.length; i += chunkSize) {
                        const chunk = rows.slice(i, i + chunkSize);
                        const { error } = await window.supabaseClient
                            .from(tableName)
                            .upsert(chunk, { onConflict: key });
                        if (error) {
                            console.error(`‚ùå Upsert error in ${tableName}:`, error);
                            throw new Error(`${tableName} ‡¶Ü‡¶™‡¶°‡ßá‡¶ü ‡¶ï‡¶∞‡¶§‡ßá ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ: ${error.message}`);
                        }
                        console.log(`   ‚úÖ ${tableName} upsert ${i + chunk.length}/${rows.length}`);
                    }
                }
                
                await batchUpsert('presiding_list', 'presiding_iid', presidingUnique);
                await batchUpsert('ass_presiding_list', 'ass_presiding_iid', assPresidingUnique);
                await batchUpsert('polling_list', 'polling_iid', pollingUnique);
                
                console.log('‚úÖ All assign_code updated in officer tables');
                
                showStatus('‚úÖ ‡¶∏‡¶´‡¶≤‡¶≠‡¶æ‡¶¨‡ßá ‡¶∏‡¶ï‡¶≤ ‡¶¶‡¶æ‡¶Ø‡¶º‡¶ø‡¶§‡ßç‡¶¨ ‡¶¨‡¶®‡ßç‡¶ü‡¶® ‡¶∏‡¶Ç‡¶∞‡¶ï‡ßç‡¶∑‡¶£ ‡¶ï‡¶∞‡¶æ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá! ‡¶Ü‡¶¨‡¶æ‡¶∞ ‡¶ú‡ßá‡¶®‡¶æ‡¶∞‡ßá‡¶ü ‡¶ï‡¶∞‡¶§‡ßá ‡¶ö‡¶æ‡¶á‡¶≤‡ßá "‡¶®‡¶§‡ßÅ‡¶® ‡¶ï‡¶∞‡ßá ‡¶¨‡¶®‡ßç‡¶ü‡¶® ‡¶ï‡¶∞‡ßÅ‡¶®" ‡¶¨‡¶æ‡¶ü‡¶® ‡¶ï‡ßç‡¶≤‡¶ø‡¶ï ‡¶ï‡¶∞‡ßÅ‡¶®‡•§', 'success');
                document.getElementById('saveBtn').style.display = 'none';
                
            } catch (error) {
                console.error('Save error:', error);
                showStatus(`‚ùå ‡¶∏‡¶Ç‡¶∞‡¶ï‡ßç‡¶∑‡¶£‡ßá ‡¶§‡ßç‡¶∞‡ßÅ‡¶ü‡¶ø: ${error.message}`, 'error');
            } finally {
                setLoading(false);
            }
        }
    </script>
</body>
</html>