<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Google Map Location - Vote Centres</title>
    <script src="https://unpkg.com/maplibre-gl@2.4.0/dist/maplibre-gl.js"></script>
    <link href="https://unpkg.com/maplibre-gl@2.4.0/dist/maplibre-gl.css" rel="stylesheet" />
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.0/jszip.min.js" integrity="sha512-xcHCGC5tQ0SHlRX8Anbz6oy/OullASJkEhb4gjkneVpGE3/QGYejf14CUO5n5q5paiHfRFTa9HKgByxzidw2Bw==" crossorigin="anonymous"></script>
    <script>if(typeof JSZip==='undefined'){var s=document.createElement('script');s.src='https://cdn.jsdelivr.net/npm/jszip@3.10.0/dist/jszip.min.js';s.crossOrigin='anonymous';document.head.appendChild(s);}</script>
    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6.5.0/turf.min.js" crossorigin="anonymous"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f4f6f9;
            margin: 0;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 20px;
        }

        .loading {
            text-align: center;
            font-size: 1.2em;
            color: #666;
            padding: 20px;
        }

        #map {
            height: 75vh; /* larger by default */
            min-height: 420px;
            max-height: 90vh;
            border-radius: 10px;
            margin-top: 16px;
            border: 1px solid rgba(15,23,42,0.06);
            box-shadow: 0 8px 24px rgba(15,23,42,0.08), 0 2px 6px rgba(15,23,42,0.04);
            transition: height 200ms ease;
        }

        /* Fullscreen support: when the container goes fullscreen, make map occupy full viewport */
        .container:-webkit-full-screen, .container:-moz-full-screen, .container:fullscreen {
            width: 100%;
            height: 100%;
            padding: 0;
            margin: 0;
            border-radius: 0;
        }
        .container:-webkit-full-screen #map, .container:-moz-full-screen #map, .container:fullscreen #map {
            height: 100vh;
            max-height: none;
            min-height: 0;
            border-radius: 0;
        }

        /* Card styles for mobile-friendly layout */
        .card-grid {
            display: grid;
            /* Single-column layout so each card occupies its own row on desktop */
            grid-template-columns: 1fr;
            gap: 16px;
            margin-top: 20px;
            list-style: none;
            padding: 0;
            align-items: stretch;
        }

        .card {
            background: #fff;
            border-radius: 10px;
            padding: 16px;
            border: 1px solid rgba(15,23,42,0.04);
            /* stronger, multi-layered shadow for consistent elevation */
            box-shadow: 0 8px 24px rgba(15,23,42,0.08), 0 2px 6px rgba(15,23,42,0.04);
            display: flex;
            flex-direction: column;
            transition: transform 160ms ease, box-shadow 160ms ease;
        }

        .card:hover {
            transform: translateY(-8px);
            box-shadow: 0 18px 44px rgba(15,23,42,0.14), 0 6px 18px rgba(15,23,42,0.08);
        }

        .card-title {
            font-size: 1.05rem;
            margin: 0 0 6px 0;
            color: #1f2937;
        }

        .card-meta {
            color: #6b7280;
            font-size: 0.95rem;
            margin-bottom: 12px;
            line-height: 1.35;
        }

        .card-actions {
            margin-top: auto;
            display: flex;
            gap: 8px;
            justify-content: flex-end; /* align actions to the right */
        }

        .map-link {
            display: inline-flex;
            align-items: center;
            padding: 8px 12px;
            background-color: #ff7a00; /* orange */
            color: white;
            text-decoration: none;
            border-radius: 8px;
            font-weight: 600;
            box-shadow: 0 6px 12px rgba(255,122,0,0.16);
        }

        .map-link:hover { background-color: #e05b00; }

        /* Filter row styles */
        .filter-row {
            display: none; /* shown after data loads */
            align-items: center;
            gap: 12px;
            margin-top: 12px;
        }

        .area-select {
            padding: 8px 10px;
            border-radius: 8px;
            border: 1px solid #e6e6e6;
            background: white;
            font-weight: 600;
        }

        .area-badge {
            color: #6b7280;
            font-weight: 600;
            margin-left: 8px;
        }

        @media (max-width: 480px) {
            .filter-row { flex-direction: column; align-items: stretch; gap: 8px; }
            .area-badge { margin-left: 0; }
        }

        .error {
            color: #dc3545;
            text-align: center;
            padding: 20px;
            background: #ffe6e6;
            border-radius: 4px;
            margin: 20px 0;
        }

        @media (max-width: 480px) {
            .container { padding: 12px; }
            .card-grid { gap: 10px; }
        }

        @media (max-width: 480px) {
            #map { height: 300px; }
        }

        /* Custom numbered marker styles */
        .numbered-marker {
            background-color: #2563eb;
            border: 3px solid white;
            border-radius: 50%;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 13px;
            box-shadow: 0 4px 12px rgba(37,99,235,0.4);
            width: 36px;
            height: 36px;
        }

        .numbered-marker:hover {
            background-color: #1e40af;
            transform: scale(1.15);
        }
    </style>
</head>
<body>

<div class="container">
    <h1>Vote Centre Locations</h1>
    <div id="status" class="loading">Loading data...</div>
    <div class="filter-row" style="display:none;">
        <label for="areaFilter" style="font-weight:600; margin-right:8px;">Filter by Area:</label>
        <select id="areaFilter" class="area-select">
            <option value="">All areas</option>
        </select>
        <span id="resultCount" class="area-badge"></span>

        <!-- Export controls -->
        <div class="export-controls" style="margin-left:auto; display:flex; gap:8px; align-items:center;">
            <label for="exportScale" style="font-weight:600; margin-right:6px;">Export:</label>
            <select id="exportScale" class="area-select" style="width:88px;">
                <option value="1">1× (standard)</option>
                <option value="2">2× (retina)</option>
                <option value="3">3×</option>
                <option value="4">4×</option>
                <option value="10" selected>10× (very high-res)</option>
            </select>
            <button id="exportMapBtn" class="map-link" style="background:#2563eb;">Export PNG</button>
            <div id="exportStatus" style="display:none; margin-left:8px; font-weight:600; color:#374151;">Preparing export…</div>
            
            <!-- Locate / Tile package export -->
            <button id="locateBtn" class="map-link" style="background:#f59e0b; margin-left:8px;">Locate Me</button>
            <div id="locateStatus" style="display:none; margin-left:8px; font-weight:600; color:#374151;">Locating…</div>

            <label for="tileZoom" style="font-weight:600; margin-left:12px; margin-right:6px;">Tiles (zoom):</label>
            <select id="tileZoom" class="area-select" style="width:84px;">
                <option value="12">12</option>
                <option value="13" selected>13</option>
                <option value="14">14</option>
                <option value="15">15</option>
                <option value="16">16</option>
            </select>
            <button id="exportTilesBtn" class="map-link" style="background:#10b981;">Export Tiles (ZIP)</button>
            <div id="exportTilesStatus" style="display:none; margin-left:8px; font-weight:600; color:#374151;">Preparing tiles…</div> 
        </div>
    </div>
    <div id="map"></div>
    <div id="nearbyContainer" style="display:none; margin-top:12px;"></div>
    <div id="table-container"></div>
</div>

<script>
    // Supabase Configuration from instructions
    const SUPABASE_URL = window.SUPABASE_URL || 'https://tschsyozvlneslqylqii.supabase.co';
    const SUPABASE_ANON_KEY = window.SUPABASE_ANON_KEY || 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InRzY2hzeW96dmxuZXNscXlscWlpIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjY3MzcyNjgsImV4cCI6MjA4MjMxMzI2OH0.7kfq7K-jbFmgnin2zkLJf7GIulGXvfQzBkzjs0iAO14';
    
    // Initialize Supabase client
    const supabaseClient = window.supabaseClient || (window.supabaseClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY));
    let voteData = []; // holds fetched vote centre records for filtering
    let map;
    let markerLayer;
    const geoCache = new Map();
    let lastGeocodingTime = 0;

    // Delay utility for rate limiting
    function delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    // Extract main location name from detailed address (removes ward numbers, street details)
    function extractMainLocation(text) {
        if (!text) return '';
        // Remove patterns like "ওয়ার্ড নং-১", numbers with slashes, parentheses content
        let cleaned = text
            .replace(/ওয়ার্ড\s*নং?[-\s]*\d+/gi, '') // Remove ward numbers
            .replace(/\d+নং?\s*ওয়ার্ড/gi, '') // Remove ward mentions
            .replace(/[-–—]\d+/g, '') // Remove dash-numbers like -197, -331
            .replace(/\([^)]*\)/g, '') // Remove parentheses content
            .replace(/\s{2,}/g, ' ') // Collapse multiple spaces
            .trim();
        // Extract first meaningful part (usually city/municipality name)
        const parts = cleaned.split(/[,،]/); // Split by comma (English or Bengali)
        return parts[0]?.trim() || cleaned;
    }

    // Function to fetch data and render table
    async function loadVoteCentres() {
        const statusDiv = document.getElementById('status');
        const tableContainer = document.getElementById('table-container');

        try {
            // Fetch relevant columns from public.vote_centre
            const { data, error } = await supabaseClient
                .from('vote_centre')
                .select('vote_centre_iid, vote_centre_code, vote_centre_name, vote_centre_location, vote_centre_area, location_url')
                .order('vote_centre_code', { ascending: true });

            if (error) {
                throw error;
            }

            if (!data || data.length === 0) {
                statusDiv.innerHTML = 'No vote centres found.';
                return;
            }

            // Store data and initialize UI
            voteData = data;
            initMap();
            populateAreaFilter(data);
            renderCards(data);
            // show filter row
            const filterRow = document.querySelector('.filter-row');
            if (filterRow) filterRow.style.display = 'flex';
            statusDiv.style.display = 'none';

        } catch (err) {
            console.error('Error fetching data:', err);
            statusDiv.className = 'error';
            statusDiv.innerHTML = `Error loading data: ${err.message}`;
        }
    }

    function initMap() {
        if (map) return;

        // Use a minimal inline style with OSM raster tiles so roads and labels are always visible
        const osmRasterStyle = {
            version: 8,
            name: 'Raster multi-source base',
            sources: {
                // Fallback base (Carto Light) — generally CORS-friendly
                'carto': {
                    type: 'raster',
                    tiles: [
                        'https://a.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png',
                        'https://b.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png',
                        'https://c.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png'
                    ],
                    scheme: 'xyz',
                    tileSize: 256,
                    minzoom: 0,
                    maxzoom: 20,
                    attribution: '© Carto, © OpenStreetMap contributors'
                },
                // Primary base (OpenStreetMap tiles)
                'osm': {
                    type: 'raster',
                    tiles: [
                        'https://a.tile.openstreetmap.org/{z}/{x}/{y}.png',
                        'https://b.tile.openstreetmap.org/{z}/{x}/{y}.png',
                        'https://c.tile.openstreetmap.org/{z}/{x}/{y}.png'
                    ],
                    scheme: 'xyz',
                    tileSize: 256,
                    minzoom: 0,
                    maxzoom: 19,
                    attribution: '© OpenStreetMap contributors'
                }
            },
            layers: [
                // Background color so we never see a transparent checkerboard
                {
                    id: 'background-fill',
                    type: 'background',
                    paint: { 'background-color': '#f0e6dc' }
                },
                // Carto as the fallback basemap (drawn first)
                {
                    id: 'carto-raster-layer',
                    type: 'raster',
                    source: 'carto'
                },
                // OSM tiles on top — if they fail to load the Carto layer shows through
                {
                    id: 'osm-raster-layer',
                    type: 'raster',
                    source: 'osm'
                }
            ]
        };

        map = new maplibregl.Map({
            container: 'map',
            style: osmRasterStyle,
            center: [91.3967, 23.0150], // Feni, Bangladesh [lng, lat]
            zoom: 12,
            scrollZoom: false
        });

        map.addControl(new maplibregl.NavigationControl());
        map.addControl(new maplibregl.AttributionControl({ compact: true }));
        try {
            const containerEl = document.querySelector('.container');
            map.addControl(new maplibregl.FullscreenControl({ container: containerEl }));
        } catch (e) {
            console.warn('FullscreenControl not available:', e);
        }
        markerLayer = []; // Store markers in array

        // Listen for general map errors and source data events to help debug tiles
        map.on('error', (e) => {
            console.warn('Map error:', e && e.error ? e.error.message || e.error : e);
        });
        map.on('sourcedata', (e) => {
            if (e && e.sourceId) {
                // When a source finishes loading we can log its status
                // e.isSourceLoaded is true when the source is ready
                console.debug('source event:', e.sourceId, 'isSourceLoaded=', e.isSourceLoaded);
            }
        });

        // Ensure the map resizes correctly when entering/exiting fullscreen
        document.addEventListener('fullscreenchange', () => {
            setTimeout(() => { if (map && map.resize) map.resize(); }, 200);
        });
    }

    function extractLatLngFromUrl(url) {
        if (!url) return null;
        try {
            const decoded = decodeURIComponent(url);
            // @lat,lng pattern
            const atMatch = decoded.match(/@(-?\d+\.\d+),(-?\d+\.\d+)/);
            if (atMatch) return [parseFloat(atMatch[1]), parseFloat(atMatch[2])];

            // Google "!3d...!4d..." format
            const bangMatch = decoded.match(/!3d(-?\d+\.\d+)!4d(-?\d+\.\d+)/);
            if (bangMatch) return [parseFloat(bangMatch[1]), parseFloat(bangMatch[2])];

            // query=lat,lng or q=lat,lng
            const queryMatch = decoded.match(/[?&]query=([^&]+)/);
            if (queryMatch) {
                const q = decodeURIComponent(queryMatch[1]);
                if (/^-?\d+(\.\d+)?,-?\d+(\.\d+)?$/.test(q)) {
                    const [lat, lng] = q.split(',').map(Number);
                    return [lat, lng];
                }
            }
            const qParam = decoded.match(/[?&]q=([^&]+)/);
            if (qParam) {
                const q = decodeURIComponent(qParam[1]);
                if (/^-?\d+(\.\d+)?,-?\d+(\.\d+)?$/.test(q)) {
                    const [lat, lng] = q.split(',').map(Number);
                    return [lat, lng];
                }
            }

            // center=lat,lng (staticmap or static endpoints)
            const centerParam = decoded.match(/[?&]center=([^&]+)/);
            if (centerParam) {
                const c = decodeURIComponent(centerParam[1]).replace(/\+/g, ' ');
                if (/^-?\d+(\.\d+)?,-?\d+(\.\d+)?$/.test(c)) {
                    const [lat, lng] = c.split(',').map(Number);
                    return [lat, lng];
                }
            }

            // ll=lat,lng
            const llParam = decoded.match(/[?&]ll=([^&]+)/);
            if (llParam) {
                const c = decodeURIComponent(llParam[1]);
                if (/^-?\d+(\.\d+)?,-?\d+(\.\d+)?$/.test(c)) {
                    const [lat, lng] = c.split(',').map(Number);
                    return [lat, lng];
                }
            }

            // /place/lat,lng pattern
            const placeMatch = decoded.match(/\/place\/(-?\d+\.\d+),(-?\d+\.\d+)/);
            if (placeMatch) return [parseFloat(placeMatch[1]), parseFloat(placeMatch[2])];

        } catch (e) {
            return null;
        }
        return null;
    }

    // Parse plain "lat,lng" strings stored in database
    function parseLatLngString(text) {
        if (!text) return null;
        const m = text.trim().match(/^(-?\d+(?:\.\d+)?)\s*,\s*(-?\d+(?:\.\d+)?)$/);
        if (m) return [parseFloat(m[1]), parseFloat(m[2])];
        return null;
    }

    // Expand shortened URLs (like goo.gl) by following redirects
    async function expandShortUrl(shortUrl) {
        if (!shortUrl) return null;
        
        // Check cache first
        const cacheKey = `expand:${shortUrl}`;
        if (geoCache.has(cacheKey)) return geoCache.get(cacheKey);
        
        // Rate limiting for proxy requests (100ms delay)
        await delay(100);
        
        try {
            // Use corsproxy.io which is more reliable
            const proxyUrl = `https://corsproxy.io/?${encodeURIComponent(shortUrl)}`;
            const response = await fetch(proxyUrl, {
                method: 'GET',
                redirect: 'follow'
            });
            
            // Try to get final URL from response.url first
            let finalUrl = response.url || '';

            // If proxy didn't follow to a final URL (still contains proxy prefix), parse the response body
            if (finalUrl && finalUrl.includes('corsproxy.io/?')) {
                const body = await response.text();

                // Look for common Google Maps targets in the HTML (canonical, og:url, direct links)
                const mapMatch = body.match(/https?:\/\/[^\s"'<>]*google\.com\/maps[^\s"'<>]*/i)
                               || body.match(/https?:\/\/maps\.app\.goo\.gl\/[^\s"'<>]*/i)
                               || body.match(/https?:\/\/maps\.google\.com\/[^\s"'<>]*/i);

                if (mapMatch && mapMatch[0]) {
                    finalUrl = mapMatch[0];
                } else {
                    // Check meta og:url
                    const og = body.match(/<meta[^>]+property=["']og:url["'][^>]+content=["']([^"']+)["']/i);
                    if (og && og[1]) finalUrl = og[1];
                }
            }

            // Clean up any proxy prefix if present
            if (finalUrl.startsWith('https://corsproxy.io/?')) {
                finalUrl = decodeURIComponent(finalUrl.replace('https://corsproxy.io/?', ''));
            }

            // If finalUrl is still the shortUrl, give up and cache null
            if (!finalUrl || finalUrl === shortUrl) {
                console.warn('Could not expand short URL (no final URL found):', shortUrl);
                geoCache.set(cacheKey, null);
                return null;
            }

            console.log('Expanded URL:', shortUrl, '->', finalUrl);
            geoCache.set(cacheKey, finalUrl);
            return finalUrl;
        } catch (e) {
            console.error('Failed to expand URL:', shortUrl, e);
            geoCache.set(cacheKey, null);
            return null;
        }
    }

    async function geocodeQuery(query) {
        if (!query) return null;
        const key = `q:${query}`;
        if (geoCache.has(key)) return geoCache.get(key);
        
        // Rate limiting: wait at least 300ms between requests
        const now = Date.now();
        const timeSinceLastRequest = now - lastGeocodingTime;
        if (timeSinceLastRequest < 300) {
            await delay(300 - timeSinceLastRequest);
        }
        lastGeocodingTime = Date.now();

        try {
            // Add Feni, Bangladesh context to improve geocoding
            const queryWithContext = query.includes('Feni, Bangladesh') ? query : `${query}, Feni, Bangladesh`;
            const url = `https://nominatim.openstreetmap.org/search?format=json&limit=1&q=${encodeURIComponent(queryWithContext)}`;
            console.log('Geocoding:', queryWithContext);
            
            const res = await fetch(url, {
                headers: {
                    'User-Agent': 'VoteCentreMap/1.0'
                }
            });
            const json = await res.json();
            
            if (json && json[0]) {
                const lat = parseFloat(json[0].lat);
                const lng = parseFloat(json[0].lon);
                const coords = [lat, lng];
                console.log('✓ Found coordinates:', coords, 'for', query);
                geoCache.set(key, coords);
                return coords;
            } else {
                console.warn('✗ No coordinates found for:', query);
            }
        } catch (e) {
            console.error('Geocoding error for', query, ':', e);
        }
        geoCache.set(key, null);
        return null;
    }

    async function renderMarkers(data) {
        if (!map) return;
        
        // Remove existing markers
        markerLayer.forEach(marker => marker.remove());
        markerLayer = [];
        
        const bounds = new maplibregl.LngLatBounds();
        let successCount = 0;
        let failCount = 0;

        console.log(`Rendering ${data.length} markers...`);

        // Process all markers in parallel batches for faster loading
        const batchSize = 10; // Process 10 markers at a time
        
        for (let batchStart = 0; batchStart < data.length; batchStart += batchSize) {
            const batch = data.slice(batchStart, batchStart + batchSize);
            
            await Promise.all(batch.map(async (centre, batchIndex) => {
                const i = batchStart + batchIndex;
                const name = centre.vote_centre_name || '';
                const location = centre.vote_centre_location || '';
                const area = centre.vote_centre_area || '';
                const locationUrl = centre.location_url || '';

                // Priority 1: explicit coordinates stored in DB (format: "lat,lng")
                let coords = parseLatLngString(centre.location_latitude_longitude);
                if (coords) {
                    console.log('Using saved coordinates for', centre.vote_centre_code || centre.vote_centre_iid, coords);
                } else {
                    // Priority 2: extract coordinates from location_url (including expanding short URLs)
                    coords = extractLatLngFromUrl(locationUrl);

                    if (!coords && locationUrl && locationUrl.trim()) {
                        // Try to extract coords from the URL directly (handles many Google link shapes)
                        coords = extractLatLngFromUrl(locationUrl);
                        if (!coords && (locationUrl.includes('goo.gl') || locationUrl.includes('maps.app.goo.gl'))) {
                            const expandedUrl = await expandShortUrl(locationUrl);
                            if (expandedUrl) {
                                coords = extractLatLngFromUrl(expandedUrl);
                                if (coords) console.log('Extracted coords from expanded URL for', centre.vote_centre_code || centre.vote_centre_iid, coords);
                            }
                        }

                        // If we found coords from URL and DB doesn't already have them, save to DB
                        if (coords && (!centre.location_latitude_longitude || !centre.location_latitude_longitude.trim())) {
                            const coordsStr = `${coords[0]},${coords[1]}`;
                            try {
                                const { data: upData, error: upErr } = await supabaseClient
                                    .from('vote_centre')
                                    .update({ location_latitude_longitude: coordsStr })
                                    .eq('vote_centre_iid', centre.vote_centre_iid);
                                if (!upErr) {
                                    centre.location_latitude_longitude = coordsStr; // update in-memory record
                                    console.log('Saved extracted coords to DB for', centre.vote_centre_iid, coordsStr);
                                } else {
                                    console.warn('Failed to save extracted coords for', centre.vote_centre_iid, upErr);
                                }
                            } catch (e) {
                                console.warn('Error saving extracted coords for', centre.vote_centre_iid, e);
                            }
                        }
                    }

                    // NOTE: Custom geocoding/search fallback has been disabled on request.
                    // We will NOT call geocodeQuery() if neither stored coords nor location_url provide coordinates.
                }

                if (coords && coords.length === 2) {
                    const [lat, lng] = coords;
                    bounds.extend([lng, lat]); // Mapbox uses [lng, lat]

                    const mapHref = (locationUrl && locationUrl.trim()) ? locationUrl : `https://www.google.com/maps/search/?api=1&query=${encodeURIComponent(lat + ',' + lng)}`;
                    const popupHtml = `
                        <strong>${name || '-'} </strong><br>
                        <span>Code: ${centre.vote_centre_code || '-'}</span><br>
                        <span>Location: ${location || '-'}</span><br>
                        <span>Area: ${area || '-'}</span><br>
                        <a href="${mapHref}" target="_blank" style="color: #ff7a00;">Open in Google Maps</a>
                    `;

                    // Create custom numbered marker element
                    const markerNumber = centre.vote_centre_code || (i + 1);
                    const el = document.createElement('div');
                    el.className = 'numbered-marker';
                    el.textContent = markerNumber;

                    // Create MapLibre marker
                    const marker = new maplibregl.Marker(el)
                        .setLngLat([lng, lat])
                        .setPopup(new maplibregl.Popup({ offset: 25 }).setHTML(popupHtml))
                        .addTo(map);

                    // attach centre info for later use (nearest listing)
                    marker._centreName = name || '';
                    marker._centreCode = centre.vote_centre_code || '';
                    markerLayer.push(marker);
                    successCount++;
                } else {
                    // No coordinates available (no DB coords and no usable location_url)
                    console.warn('No coordinates for centre', centre.vote_centre_code || centre.vote_centre_iid, 'location_url=', locationUrl ? 'present' : 'absent');
                    failCount++;
                }
            }));
            
            if (!bounds.isEmpty()) {
                map.fitBounds(bounds, { padding: 50 });
            }
        }

        console.log(`Map markers: ${successCount} shown, ${failCount} failed`);

        if (bounds.isEmpty()) {
            // Fallback to Feni, Bangladesh center if no markers
            map.setCenter([91.3967, 23.0150]);
            map.setZoom(12);
        }
    }

    // Populate area dropdown with unique areas
    function populateAreaFilter(data) {
        const sel = document.getElementById('areaFilter');
        if (!sel) return;
        // compute unique areas (use 'Unknown' for empty)
        const areas = Array.from(new Set(data.map(d => (d.vote_centre_area && d.vote_centre_area.toString().trim()) ? d.vote_centre_area.toString().trim() : 'Unknown')));
        areas.sort((a,b) => a.localeCompare(b));
        // clear existing (except All areas)
        sel.innerHTML = '<option value="">All areas</option>';
        areas.forEach(a => {
            const opt = document.createElement('option');
            opt.value = a;
            opt.textContent = a === 'Unknown' ? 'Unknown' : a;
            sel.appendChild(opt);
        });
        sel.addEventListener('change', function() {
            renderCards(voteData, this.value);
        });
    }

    // Render cards, optionally filter by area
    function renderCards(data, areaFilter = '') {
        const tableContainer = document.getElementById('table-container');
        const resultCount = document.getElementById('resultCount');
        if (!tableContainer) return;
        const filtered = data.filter(d => {
            const area = (d.vote_centre_area && d.vote_centre_area.toString().trim()) ? d.vote_centre_area.toString().trim() : 'Unknown';
            return !areaFilter || areaFilter === '' ? true : area === areaFilter;
        });
        let html = '<div class="card-grid">';
        filtered.forEach(centre => {
            const code = centre.vote_centre_code || '';
            const name = centre.vote_centre_name || '';
            const location = centre.vote_centre_location || '';
            const area = centre.vote_centre_area || '';
            const locationUrl = centre.location_url || '';
            const locationParts = [name, location, area].filter(part => part && part.trim() !== '');
            const query = locationParts.join(', ');
            const encodedQuery = encodeURIComponent(query);
            const mapUrl = `https://www.google.com/maps/search/?api=1&query=${encodedQuery}`;
            const finalMapHref = locationUrl && locationUrl.trim() ? locationUrl : mapUrl;
            html += `<article class="card">\n                        <div>\n                            <h2 class="card-title">${name || '-'} </h2>\n                            <div class="card-meta"><strong>Code:</strong> ${code || '-'} &nbsp; <strong>Location:</strong> ${location || '-'} &nbsp; <strong>Area:</strong> ${area || '-'}</div>\n                        </div>\n                        <div class="card-actions">\n                            <a href="${finalMapHref}" target="_blank" class="map-link">Open Map</a>\n                        </div>\n                    </article>`;
        });
        html += '</div>';
        tableContainer.innerHTML = html;
        renderMarkers(filtered);
        if (resultCount) resultCount.textContent = `${filtered.length} centre(s)`;
    }

    // High-resolution export: captures map canvas and redraws crisp marker overlays
    // Fetch tile image helper (returns Image or null on failure)
    function loadTileImage(url) {
        return new Promise((resolve) => {
            const img = new Image();
            img.crossOrigin = 'anonymous';
            img.onload = () => resolve(img);
            img.onerror = () => resolve(null);
            img.src = url;
        });
    }

    function tile2lon(x, z) { return (x / Math.pow(2, z)) * 360 - 180; }
    function tile2lat(y, z) {
        const n = Math.PI - (2 * Math.PI * y) / Math.pow(2, z);
        return (180 / Math.PI) * Math.atan(0.5 * (Math.exp(n) - Math.exp(-n)));
    }

    // Wait for the map to report 'idle' (all visible tiles and sources loaded) or timeout
    function waitForMapIdle(timeoutMs = 15000) {
        return new Promise((resolve) => {
            if (!map) return resolve(false);
            let done = false;
            const onIdle = () => { if (!done) { done = true; cleanup(); resolve(true); } };
            const cleanup = () => { map.off('idle', onIdle); clearTimeout(timer); };
            const timer = setTimeout(() => { if (!done) { done = true; cleanup(); resolve(false); } }, timeoutMs);
            try {
                map.once('idle', onIdle);
            } catch (e) {
                // If 'idle' event not available, fallback to short delay and hope tiles load
                setTimeout(() => { cleanup(); resolve(false); }, Math.min(timeoutMs, 2000));
            }
        });
    }

    // Haversine distance (meters)
    function distanceMeters(lat1, lon1, lat2, lon2) {
        function toRad(deg){return deg * Math.PI / 180;}
        const R = 6371000; // meters
        const dLat = toRad(lat2 - lat1);
        const dLon = toRad(lon2 - lon1);
        const a = Math.sin(dLat/2)*Math.sin(dLat/2) + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)*Math.sin(dLon/2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        return R * c;
    }

    let userMarker = null;
    let userAccuracyCircle = null;

    async function locateUser(options={enableHighAccuracy:true, timeout:15000, maximumAge:0}){
        const btn = document.getElementById('locateBtn');
        const statusEl = document.getElementById('locateStatus');
        if (!('geolocation' in navigator)) {
            alert('Geolocation not supported by this browser.');
            return;
        }
        btn.disabled = true; btn.style.opacity = 0.6;
        statusEl.style.display = 'inline-block'; statusEl.textContent = 'Locating…';

        const onSuccess = (pos) => {
            const lat = pos.coords.latitude; const lng = pos.coords.longitude; const acc = pos.coords.accuracy || 0;
            statusEl.textContent = `Located: ${lat.toFixed(5)}, ${lng.toFixed(5)} (±${Math.round(acc)}m)`;

            // Add or move user marker
            if (userMarker) { userMarker.setLngLat([lng, lat]); }
            else {
                const el = document.createElement('div');
                el.style.width = '18px'; el.style.height = '18px'; el.style.borderRadius='50%'; el.style.background='#ef4444'; el.style.border='3px solid white';
                userMarker = new maplibregl.Marker({element: el}).setLngLat([lng, lat]).addTo(map);
            }

            // accuracy circle (as geojson layer)
            if (userAccuracyCircle) { map.removeLayer('user-accuracy'); map.removeSource('user-accuracy'); userAccuracyCircle=null; }
            try {
                const circle = turf.circle([lng, lat], acc/1000, {steps: 32, units: 'kilometers'});
                map.addSource('user-accuracy', { type: 'geojson', data: circle });
                map.addLayer({ id: 'user-accuracy', type: 'fill', source: 'user-accuracy', paint: { 'fill-color': '#ef4444', 'fill-opacity': 0.08, 'fill-outline-color': '#ef4444' } });
                userAccuracyCircle = true;
            } catch (e) {
                // turf may not be available; ignore
            }

            // center map (if not already near)
            map.flyTo({ center: [lng, lat], zoom: Math.max(map.getZoom(), 14) });

            // Show nearest centres
            showNearestCenters(lat, lng, 6);

            btn.disabled = false; btn.style.opacity = 1;
            setTimeout(()=>{statusEl.style.display='none';}, 5000);
        };

        const onError = (err) => {
            console.warn('Geolocation error:', err);
            alert('Failed to get location: ' + (err && err.message ? err.message : err));
            btn.disabled = false; btn.style.opacity = 1;
            statusEl.style.display = 'none';
        };

        navigator.geolocation.getCurrentPosition(onSuccess, onError, options);
    }

    // Show nearest vote centres (n) in nearbyContainer and highlight on the map
    function showNearestCenters(lat, lng, n=6){
        if (!markerLayer || markerLayer.length===0) return;
        const entries = [];
        for (const m of markerLayer) {
            try {
                const ll = m.getLngLat();
                const d = distanceMeters(lat, lng, ll.lat, ll.lng);
                entries.push({ marker: m, lat: ll.lat, lng: ll.lng, dist: d, el: m.getElement() });
            } catch(e){ }
        }
        entries.sort((a,b)=>a.dist-b.dist);
        const top = entries.slice(0, n);

        const panel = document.getElementById('nearbyContainer');
        panel.innerHTML = '';
        const list = document.createElement('div');
        list.className = 'card';
        list.style.padding='12px';
        list.style.maxHeight='220px';
        list.style.overflow='auto';
        list.innerHTML = `<h3 style="margin:0 0 8px 0; font-size:1rem;">Nearest ${top.length} centres</h3>`;
        top.forEach((t, i) => {
            const item = document.createElement('div');
            item.style.borderTop = i===0 ? 'none' : '1px solid rgba(0,0,0,0.06)';
            item.style.padding = '8px 0';
            const name = (t.marker && t.marker._centreName) ? t.marker._centreName : 'Centre';
            const distanceText = t.dist > 1000 ? (t.dist/1000).toFixed(2)+' km' : Math.round(t.dist)+' m';
            item.innerHTML = `<strong>${name || 'Centre'}</strong><div style="color:#6b7280; font-size:0.9rem;">${distanceText}</div>`;
            item.style.cursor = 'pointer';
            item.addEventListener('click', () => {
                map.flyTo({center:[t.lng,t.lat], zoom:16});
                if (typeof t.marker.togglePopup === 'function') {
                    t.marker.togglePopup();
                } else if (t.marker.getPopup && typeof t.marker.getPopup === 'function') {
                    try { t.marker.getPopup().addTo(map); } catch (e) {}
                }
            });
            list.appendChild(item);
        });
        panel.appendChild(list);
        panel.style.display='block';
    }


    async function exportMapHighRes(scale = 10) {
        if (!map) return alert('Map not initialized');
        scale = Math.max(1, Math.min(10, Number(scale) || 10));

        // Use CSS pixel size of map container (map.project uses CSS pixels)
        const width = map.getContainer().clientWidth;
        const height = map.getContainer().clientHeight;

        // Create export canvas at higher pixel density
        const exportCanvas = document.createElement('canvas');
        exportCanvas.width = Math.round(width * scale);
        exportCanvas.height = Math.round(height * scale);
        const ctx = exportCanvas.getContext('2d');
        ctx.scale(scale, scale);

        const currentZoom = map.getZoom();
        // Choose exportZoom higher than current to capture more detail. Add extra zoom based on scale.
        const extraZoom = Math.min(6, Math.ceil(Math.log2(scale))); // conservative extra zoom
        const exportZoom = Math.max(0, Math.min(19, Math.floor(currentZoom) + extraZoom));
        const z = exportZoom;

        const bounds = map.getBounds();
        const nw = bounds.getNorthWest();
        const se = bounds.getSouthEast();

        // world pixel at zoom z
        function lonToWorldX(lon, z) { return ((lon + 180) / 360) * (256 * Math.pow(2, z)); }
        function latToWorldY(lat, z) {
            const rad = lat * Math.PI / 180;
            const n = Math.log(Math.tan(rad) + 1 / Math.cos(rad));
            return (1 - n / Math.PI) / 2 * (256 * Math.pow(2, z));
        }

        // compute world pixel for NW corner at exportZoom
        const worldNWx = lonToWorldX(nw.lng, z);
        const worldNWy = latToWorldY(nw.lat, z);

        // helper to convert tile x,y at zoom z to pixel position in CSS pixels relative to top-left of viewport
        const scaleZoomFactor = Math.pow(2, z - currentZoom);
        function tilePixelPos(x, y) {
            const tileWorldX = x * 256;
            const tileWorldY = y * 256;
            const px = (tileWorldX - worldNWx) / scaleZoomFactor;
            const py = (tileWorldY - worldNWy) / scaleZoomFactor;
            const pw = 256 / scaleZoomFactor;
            const ph = 256 / scaleZoomFactor;
            return { px, py, pw, ph };
        }

        // tile index helpers at zoom z
        function lon2tile(lon, z) { return Math.floor(((lon + 180) / 360) * Math.pow(2, z)); }
        function lat2tile(lat, z) {
            const rad = (lat * Math.PI) / 180;
            return Math.floor((1 - Math.log(Math.tan(rad) + 1 / Math.cos(rad)) / Math.PI) / 2 * Math.pow(2, z));
        }

        const xMin = lon2tile(nw.lng, z) - 1;
        const xMax = lon2tile(se.lng, z) + 1;
        const yMin = lat2tile(nw.lat, z) - 1;
        const yMax = lat2tile(se.lat, z) + 1;

        // choose tile provider with CORS-friendly tiles
        const tileTemplates = [
            'https://a.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png',
            'https://b.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png',
            'https://c.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png'
        ];

        const tilePromises = [];
        for (let x = xMin; x <= xMax; x++) {
            for (let y = yMin; y <= yMax; y++) {
                const maxTiles = Math.pow(2, z);
                const xWrapped = ((x % maxTiles) + maxTiles) % maxTiles;
                const subdomain = ((xWrapped + y) % 3 + 3) % 3; // pick a/b/c
                const url = tileTemplates[subdomain].replace('{z}', z).replace('{x}', xWrapped).replace('{y}', y);
                const pos = tilePixelPos(x, y);

                tilePromises.push((async () => {
                    const img = await loadTileImage(url);
                    return { img, pos, url };
                })());
            }
        }

        // Draw background so transparent areas are not checkerboard in exported PNG
        ctx.fillStyle = '#f0e6dc';
        ctx.fillRect(0, 0, width, height);

        const results = await Promise.all(tilePromises);
        let drawnTiles = 0;
        for (const r of results) {
            if (r.img) {
                try {
                    ctx.drawImage(r.img, r.pos.px, r.pos.py, r.pos.pw, r.pos.ph);
                    drawnTiles++;
                } catch (e) {
                    console.warn('Failed to draw tile', r.url, e);
                }
            }
        }

        if (drawnTiles === 0) {
            console.warn('No tiles fetched during export; markers will be drawn over plain background.');
            // As fallback try to draw map canvas scaled (may be blurry)
            try {
                const mapCanvas = map.getCanvas();
                ctx.drawImage(mapCanvas, 0, 0, width, height);
            } catch (e) {
                console.warn('Fallback draw of map canvas failed:', e);
            }
        }

        // Draw crisp markers (vector) on top
        for (const marker of markerLayer) {
            try {
                const ll = marker.getLngLat();
                const p = map.project([ll.lng, ll.lat]); // CSS pixels
                const radius = 18;
                const x = p.x;
                const y = p.y;

                ctx.beginPath();
                ctx.fillStyle = 'rgba(37,99,235,0.18)';
                ctx.arc(x, y, radius + 6, 0, Math.PI * 2);
                ctx.fill();

                ctx.beginPath();
                ctx.fillStyle = '#ffffff';
                ctx.arc(x, y, radius + 3, 0, Math.PI * 2);
                ctx.fill();

                ctx.beginPath();
                ctx.fillStyle = '#2563eb';
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();

                const label = (marker.getElement && marker.getElement().textContent) ? marker.getElement().textContent.trim() : '';
                ctx.fillStyle = '#ffffff';
                ctx.font = '700 13px / 1 Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(label, x, y + 1);
            } catch (e) {
                console.warn('Failed to draw marker during export:', e);
            }
        }

        // Trigger download and wait for blob creation
        await new Promise((resolve, reject) => {
            exportCanvas.toBlob(blob => {
                if (!blob) return reject(new Error('Export failed: could not create image.'));
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `vote_centres_map_${scale}x_z${z}.png`;
                document.body.appendChild(a);
                a.click();
                setTimeout(() => { URL.revokeObjectURL(url); a.remove(); resolve(); }, 2000);
            }, 'image/png', 1);
        });
    }

    // Helper: fetch a URL and return blob (null on failure)
    async function fetchTileBlob(url) {
        try {
            const res = await fetch(url, { mode: 'cors' });
            if (!res.ok) return null;
            const blob = await res.blob();
            return blob;
        } catch (e) {
            return null;
        }
    }

    // Export tiles for current view at a single zoom level into a zip. Limits total tiles to avoid runaway downloads.
    async function exportTilesZip(zoom) {
        if (!map) return alert('Map not initialized');
        zoom = Math.max(0, Math.min(19, Number(zoom) || Math.round(map.getZoom())));

        const bounds = map.getBounds();
        const nw = bounds.getNorthWest();
        const se = bounds.getSouthEast();

        function lon2tile(lon, z) { return Math.floor(((lon + 180) / 360) * Math.pow(2, z)); }
        function lat2tile(lat, z) {
            const rad = (lat * Math.PI) / 180;
            return Math.floor((1 - Math.log(Math.tan(rad) + 1 / Math.cos(rad)) / Math.PI) / 2 * Math.pow(2, z));
        }

        const xMin = lon2tile(nw.lng, zoom) - 0;
        const xMax = lon2tile(se.lng, zoom) + 0;
        const yMin = lat2tile(nw.lat, zoom) - 0;
        const yMax = lat2tile(se.lat, zoom) + 0;

        // compute total tiles
        const tileCount = Math.max(0, (xMax - xMin + 1) * (yMax - yMin + 1));
        const MAX_TILES = 2500; // safety limit
        if (tileCount > MAX_TILES) {
            if (!confirm(`This export will download ${tileCount} tiles (zoom ${zoom}). This may be large. Continue?`)) return;
        }

        const statusEl = document.getElementById('exportTilesStatus');
        const btn = document.getElementById('exportTilesBtn');
        statusEl.style.display = 'inline-block';
        btn.disabled = true; btn.style.opacity = 0.6;
        statusEl.textContent = `Collecting ${tileCount} tiles…`;

        const zip = new JSZip();
        const folder = zip.folder(`tiles_z${zoom}`);

        // simple tile templates (Carto) — CORS-friendly
        const tileTemplates = [
            'https://a.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png',
            'https://b.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png',
            'https://c.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png'
        ];

        let fetched = 0;
        const tasks = [];
        for (let x = xMin; x <= xMax; x++) {
            for (let y = yMin; y <= yMax; y++) {
                const maxTiles = Math.pow(2, zoom);
                const xWrapped = ((x % maxTiles) + maxTiles) % maxTiles;
                const subdomain = ((xWrapped + y) % 3 + 3) % 3;
                const url = tileTemplates[subdomain].replace('{z}', zoom).replace('{x}', xWrapped).replace('{y}', y);
                const path = `${zoom}/${xWrapped}/${y}.png`;
                tasks.push({ url, path });
            }
        }

        // Limit concurrency
        const CONCURRENCY = 8;
        async function worker(list) {
            for (const t of list) {
                const blob = await fetchTileBlob(t.url);
                if (blob) {
                    folder.file(t.path, blob);
                }
                fetched++;
                statusEl.textContent = `Downloading tiles… ${fetched}/${tileCount}`;
            }
        }

        // Split tasks into batches
        const batches = [];
        for (let i = 0; i < tasks.length; i += CONCURRENCY) batches.push(tasks.slice(i, i + CONCURRENCY));
        for (const b of batches) {
            await Promise.all(b.map(t => worker([t])));
        }

        statusEl.textContent = 'Creating ZIP file…';
        const blob = await zip.generateAsync({ type: 'blob' }, (meta) => {
            statusEl.textContent = `Zipping: ${Math.round(meta.percent)}%`;
        });

        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `tiles_z${zoom}.zip`;
        document.body.appendChild(a);
        a.click();
        setTimeout(() => { URL.revokeObjectURL(url); a.remove(); statusEl.style.display = 'none'; btn.disabled = false; btn.style.opacity = 1; }, 2000);
    }

    // Wire export UI (waits for map to finish loading tiles)
    document.addEventListener('click', async (e) => {
        if (e.target && e.target.id === 'exportMapBtn') {
            const btn = e.target;
            const scaleSel = document.getElementById('exportScale');
            const statusEl = document.getElementById('exportStatus');
            const scale = scaleSel ? parseInt(scaleSel.value, 10) : 2;

            // UI: disable while exporting
            btn.disabled = true; btn.style.opacity = 0.6;
            statusEl.style.display = 'inline-block';
            statusEl.textContent = 'Waiting for map tiles to finish loading…';

            const idle = await waitForMapIdle(20000); // wait up to 20s
            if (!idle) {
                statusEl.textContent = 'Map still loading — proceeding with export (tiles may be missing)...';
                console.warn('Export proceeded after timeout waiting for idle.');
            } else {
                statusEl.textContent = 'Map ready — exporting…';
            }

            try {
                await exportMapHighRes(scale);
                statusEl.textContent = 'Export complete';
            } catch (err) {
                console.error('Export failed:', err);
                statusEl.textContent = 'Export failed';
                alert('Export failed: ' + (err && err.message ? err.message : err));
            } finally {
                setTimeout(() => { statusEl.style.display = 'none'; btn.disabled = false; btn.style.opacity = 1; }, 1200);
            }
        }

        if (e.target && e.target.id === 'exportTilesBtn') {
            const zoomSel = document.getElementById('tileZoom');
            const zoom = zoomSel ? parseInt(zoomSel.value, 10) : Math.round(map.getZoom());
            await exportTilesZip(zoom);
        }

        if (e.target && e.target.id === 'locateBtn') {
            // start geolocation flow
            const btn = e.target;
            const statusEl = document.getElementById('locateStatus');
            try {
                await locateUser({ enableHighAccuracy: true, timeout: 15000, maximumAge: 0 });
            } catch (err) {
                console.error('Locate failed', err);
                alert('Locate failed: ' + (err && err.message ? err.message : err));
            }
        }
    });

    // Load data on page load
    document.addEventListener('DOMContentLoaded', loadVoteCentres);
</script>

</body>
</html>
